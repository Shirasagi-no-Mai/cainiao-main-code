import base64
import inspect
import json
import uuid
import os
import re
import math
import subprocess
import glob
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from dateutil import parser
from urllib3.util.retry import Retry
from webdriver_manager.chrome import ChromeDriverManager
import sys
import time
import traceback
import uuid
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
from tkinter import Toplevel
from tkinter import ttk

import openpyxl
import pandas as pd
import requests
import tkinter as tk
from openpyxl import Workbook
from openpyxl.styles import PatternFill
from openpyxl.utils import get_column_letter

import customtkinter as ctk
from tkinter import messagebox
import threading
from requests.adapters import HTTPAdapter
from requests.exceptions import ConnectionError, RequestException, Timeout

from selenium import webdriver
from selenium.common.exceptions import (
    ElementNotInteractableException,
    NoAlertPresentException,
    NoSuchElementException,
    TimeoutException
)

# *************************通过个人网页更新过期日期*************************************************************************t
CONFIG_URL = "https://raw.githubusercontent.com/Shirasagi-no-Mai/my-exe-control/main/expiration_config.json"


def fetch_expiration_date():
    try:
        response = requests.get(CONFIG_URL)
        response.raise_for_status()
        config = json.loads(response.text)
        return datetime.strptime(config['expiration_date'], '%Y-%m-%d')
    except requests.exceptions.RequestException as e:
        print(f"网络请求失败: {e}")

        return None
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"解析错误: {e}")
        return None


expiration_date1 = fetch_expiration_date()
print(f"expiration_date1: {expiration_date1}")

# ② 功能权限配置
# ----------------------------
PERMISSION_URL = "https://raw.githubusercontent.com/Shirasagi-no-Mai/my-exe-control2/refs/heads/main/onlinecode"


def fetch_permissions():
    """从远程读取功能权限列表"""
    try:
        response = requests.get(PERMISSION_URL, timeout=10)
        response.raise_for_status()
        data = response.json()
        permissions = {f["name"]: f["allowed_users"] for f in data.get("functions", [])}
        return permissions
    except requests.exceptions.RequestException as e:
        print(f"网络请求失败: {e}")
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"解析错误: {e}")
    return {}


permissions = fetch_permissions()


def is_user_allowed(func_name, username):
    """检查用户是否有权限执行某函数"""
    return username in permissions.get(func_name, [])


# ----------------------------
# ✅ 示例执行
# ----------------------------


permissions = fetch_permissions()
print("权限列表示例：")
print(json.dumps(permissions, indent=2, ensure_ascii=False))

# *************************通过个人网页更新过期日期*************************************************************************


# *************************预设*****************************************************************************************

# 更新输出文本框
windowname = ""


def update_output_text(output_text, message):
    output_text.insert(tk.END, message)
    output_text.yview(tk.END)


# *************************预设*****************************************************************************************
def creat_node_task(output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到BBCreview\n")
            pass
        else:
            # 创建空的 Excel 文件
            update_output_text(output_text, '错误没能找到BBCreview\n')
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止

    if desktop_path:
        file_path = os.path.join(desktop_path, "AGS-Cainiao Daily report.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到AGS sheet\n")
            pass
        else:
            # 创建空的 Excel 文件
            update_output_text(output_text, '错误没能找到AGS sheet\n')
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止

    # 检查桌面路径
    update_output_text(output_text, "开始检查桌面路径...\n")
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)
    if not desktop_path:
        update_output_text(output_text, "错误：无法找到桌面路径\n")
        sys.exit()
    update_output_text(output_text, f"找到桌面路径: {desktop_path}\n")

    # 检查并加载 BBCreview.xlsx
    file_path_bbc = os.path.join(desktop_path, "BBCreview.xlsx")
    update_output_text(output_text, f"检查 BBCreview.xlsx 是否存在: {file_path_bbc}\n")
    if not os.path.exists(file_path_bbc):
        update_output_text(output_text, "错误：未找到 BBCreview.xlsx\n")
        sys.exit()
    update_output_text(output_text, "已找到 BBCreview.xlsx\n")

    # 检查并加载 AGS-Cainiao Daily report.xlsx
    file_path_ags = os.path.join(desktop_path, "AGS-Cainiao Daily report.xlsx")
    update_output_text(output_text, f"检查 AGS-Cainiao Daily report.xlsx 是否存在: {file_path_ags}\n")
    if not os.path.exists(file_path_ags):
        update_output_text(output_text, "错误：未找到 AGS-Cainiao Daily report.xlsx\n")
        sys.exit()
    update_output_text(output_text, "已找到 AGS-Cainiao Daily report.xlsx\n")

    # **********************************************
    update_output_text(output_text, "加载 AGS 文件（确保读取值为非公式）...\n")
    wb_ags = openpyxl.load_workbook(file_path_ags, data_only=True)
    ws_ags = wb_ags.active
    update_output_text(output_text, f"AGS 文件工作表: {ws_ags.title}, 最大行数: {ws_ags.max_row}\n")

    # 保存 AGS 文件（确保公式已转换为值）
    update_output_text(output_text, "保存 AGS 文件以确保所有单元格为值...\n")
    wb_ags.save(file_path_ags)
    update_output_text(output_text, "AGS 文件已保存\n")

    # 加载 BBC 文件
    update_output_text(output_text, "加载 BBCreview.xlsx...\n")
    wb_bbc = openpyxl.load_workbook(file_path_bbc)
    ws_bbc = wb_bbc.active
    update_output_text(output_text, f"BBC 文件工作表: {ws_bbc.title}, 最大行数: {ws_bbc.max_row}\n")

    # 检查 BBC 是否有表头
    update_output_text(output_text, "检查 BBC 文件是否有表头（A1 是否为空）...\n")
    has_header = ws_bbc['A1'].value is not None
    start_row = 2 if has_header else 1
    update_output_text(output_text, f"是否有表头: {has_header}, 数据起始行: {start_row}\n")

    # 提取 BBC 第一列数据（跳过表头，去掉空格）
    update_output_text(output_text, "提取 BBC 第一列数据（跳过表头，去掉空格）...\n")
    first_column_values = [
        str(ws_bbc.cell(row=row, column=1).value).replace(" ", "")
        for row in range(start_row, ws_bbc.max_row + 1)
        if ws_bbc.cell(row=row, column=1).value is not None
    ]
    update_output_text(output_text, f"提取的 BBC 第一列数据: {first_column_values}\n")

    # 定义时间格式的正则表达式
    update_output_text(output_text, "初始化时间格式正则表达式...\n")

    time_patterns = [
        re.compile(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}$'),  # 2025-10-14 12:31:00
        re.compile(r'^(?:[A-Z\s]+-\d+/\d+\s+)?[A-Z\s]+-\d+\s+[A-Z0-9\s]+\s+\d{1,2}/\d{1,2}\s+\d{1,2}:\d{2}$'),
        # UNI-41/42 2P 10/22 22:35
        re.compile(r'^(?:[A-Z\s]+)?[A-Z\s]+\s+[A-Z0-9\s]+\s+\d{1,2}/\d{1,2}\s+\d{1,2}:\d{2}$'),
        # SELF PU COE-28 2P 10/22 16:30
        re.compile(r'^\d{1,2}/\d{1,2}/\d{4}\s+\d{1,2}:\d{2}:\d{2}\s+[AP]M$'),  # 10/22/2025 9:35:00 AM
        re.compile(r'^\d{1,2}/\d{1,2}\s+\d{1,2}:\d{2}$'),  # 10/8 10:11
    ]
    update_output_text(output_text, "正则表达式初始化完成\n")

    # ==================== 时间转换函数 ====================
    def convert_to_standard_time(time_str):
        update_output_text(output_text, f"尝试转换时间: {time_str}\n")
        try:
            # 获取当前日期
            now = datetime.now()
            today = now.date()

            # 处理 datetime 对象
            if isinstance(time_str, datetime):
                dt = time_str
                update_output_text(output_text,
                                   f"datetime 对象直接转换: {time_str} -> {dt.strftime('%Y-%m-%d %H:%M:%S')}\n")
                return dt.strftime("%Y-%m-%d %H:%M:%S")

            # 确保输入是字符串
            time_str = str(time_str).strip()

            # 1. 标准格式：2025-10-14 12:31:00
            if re.match(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}$', time_str):
                dt = datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S")
                update_output_text(output_text,
                                   f"转换标准时间格式成功: {time_str} -> {dt.strftime('%Y-%m-%d %H:%M:%S')}\n")
                return dt.strftime("%Y-%m-%d %H:%M:%S")

            # 2. 带 AM/PM 格式：10/22/2025 9:35:00 AM
            match = re.match(r'^(\d{1,2})/(\d{1,2})/(\d{4})\s+(\d{1,2}:\d{2}:\d{2})\s+([AP]M)$', time_str)
            if match:
                month, day, year, time_part, ampm = match.groups()
                dt = datetime.strptime(f"{year}-{month}-{day} {time_part} {ampm}", "%Y-%m-%d %I:%M:%S %p")
                update_output_text(output_text,
                                   f"转换 AM/PM 格式成功: {time_str} -> {dt.strftime('%Y-%m-%d %H:%M:%S')}\n")
                return dt.strftime("%Y-%m-%d %H:%M:%S")

            # 3. 无年份格式：10/8 10:11 或 UNI-41/42 2P 10/22 22:35
            match = re.search(r'(\d{1,2})/(\d{1,2})\s+(\d{1,2}:\d{2})', time_str)
            if match:
                month, day, time_part = match.groups()
                month, day = int(month), int(day)

                # 尝试当前年份和前一年，选最近的“今天或过去”日期
                candidates = []
                for year in [now.year, now.year - 1]:
                    try:
                        dt = datetime.strptime(f"{year}/{month}/{day} {time_part}", "%Y/%m/%d %H:%M")
                        candidates.append(dt)
                    except ValueError:
                        continue  # 跳过无效日期（如 2/30）

                if not candidates:
                    update_output_text(output_text, f"时间 {time_str} 日期无效: {month}/{day}\n")
                    return None

                # 选择“今天或过去”的最近日期
                past_or_today = [dt for dt in candidates if dt.date() <= today]
                if past_or_today:
                    dt = max(past_or_today, key=lambda x: x.date())  # 最近的过去或今天
                else:
                    dt = min(candidates, key=lambda x: (x.date() - today).days)  # 极少数情况选最近未来日期

                update_output_text(output_text,
                                   f"转换无年份格式成功: {time_str} -> {dt.strftime('%Y-%m-%d %H:%M:%S')} (年份: {dt.year})\n")
                return dt.strftime("%Y-%m-%d %H:%M:%S")

            update_output_text(output_text, f"时间 {time_str} 无法解析\n")
            return None

        except ValueError as e:
            update_output_text(output_text, f"时间转换错误: {time_str}, 错误信息: {e}\n")
            return None

    # ==================== 主逻辑 ====================
    update_output_text(output_text, "开始处理 BBC 参数...\n")
    max_row = ws_bbc.max_row
    for row in range(2, max_row + 1):  # 从第 2 行开始
        ws_bbc[f'M{row}'] = None
        ws_bbc[f'N{row}'] = None

    for bbc_row, param in enumerate(first_column_values, start=start_row):

        update_output_text(output_text, f"\n处理 BBC 参数: {param} (BBC 行: {bbc_row})\n")

        # 在 AGS 第三列查找匹配参数
        update_output_text(output_text, f"在 AGS 第三列查找参数: {param}\n")
        ags_row = None
        for row in range(1, ws_ags.max_row + 1):
            ags_value = str(ws_ags.cell(row=row, column=3).value or "").replace(" ", "")
            if ags_value == param:
                ags_row = row
                break
        if ags_row is None:
            update_output_text(output_text, f"参数 {param} 在 AGS 第三列未找到，跳过\n")
            continue
        update_output_text(output_text, f"找到匹配: 参数 {param} 在 AGS 第 {ags_row} 行\n")

        # 获取 AGS 的 G, K, L, M, O 列值
        update_output_text(output_text, f"提取 AGS 第 {ags_row} 行的 G, K, L, M, O 列值...\n")
        ags_cols = {
            'G': ws_ags.cell(row=ags_row, column=7).value,
            'K': ws_ags.cell(row=ags_row, column=11).value,
            'L': ws_ags.cell(row=ags_row, column=12).value,
            'M': ws_ags.cell(row=ags_row, column=13).value,
            'N': ws_ags.cell(row=ags_row, column=14).value,
            'P': ws_ags.cell(row=ags_row, column=16).value
        }
        update_output_text(output_text,
                           f"AGS 列值: G={ags_cols['G']}, K={ags_cols['K']}, L={ags_cols['L']}, M={ags_cols['M']}, N={ags_cols['N']}, P={ags_cols['P']}\n")

        # 检查是否为时间格式
        update_output_text(output_text, "检查 AGS 列值是否为时间格式...\n")
        ags_times = {col: None for col in ags_cols}
        for col, value in ags_cols.items():
            if value:  # 检查非空值（包括字符串和 datetime）
                standard_time = convert_to_standard_time(value)
                if standard_time:
                    ags_times[col] = standard_time
                    update_output_text(output_text, f"列 {col} 包含有效时间: {value} -> 转换后: {standard_time}\n")
                else:
                    update_output_text(output_text, f"列 {col} 时间格式不匹配: {value}\n")
            else:
                update_output_text(output_text, f"列 {col} 无值: {value}\n")
        update_output_text(output_text, f"有效时间: {ags_times}\n")

        # 获取 BBC 的 E, F, G, I, J, K 列值
        update_output_text(output_text, f"提取 BBC 第 {bbc_row} 行的 E, F, G, I, J, K 列值...\n")
        bbc_values = {
            'E': ws_bbc.cell(row=bbc_row, column=5).value,
            'F': ws_bbc.cell(row=bbc_row, column=6).value,
            'G': ws_bbc.cell(row=bbc_row, column=7).value,
            'I': ws_bbc.cell(row=bbc_row, column=9).value,
            'J': ws_bbc.cell(row=bbc_row, column=10).value,
            'K': ws_bbc.cell(row=bbc_row, column=11).value,
            'L': ws_bbc.cell(row=bbc_row, column=12).value
        }

        # 应用规则
        if bbc_values['E'] == "N" and bbc_values['F'] == "N" and bbc_values['G'] == 0:
            if ags_times['G']:
                ws_bbc[f'M{bbc_row}'] = 1
                ws_bbc[f'N{bbc_row}'] = ags_times['G']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=1, M{bbc_row}={ags_times['G']} (规则 1)\n")
                continue
            else:
                ws_bbc[f'M{bbc_row}'] = None
                ws_bbc[f'N{bbc_row}'] = None
                update_output_text(output_text, f"规则 1 AGS G 未满足，清空 L{bbc_row} 和 M{bbc_row}，跳过本次循环\n")
                continue
        else:
            update_output_text(output_text, f"规则 1 BBC 条件未满足，继续检查下一规则\n")

        if bbc_values['F'] == "N" and bbc_values['G'] == 0:
            if ags_times['P']:
                update_output_text(output_text, f"规则 2 匹配: AGS O={ags_times['P']}, BBC F='N', G=0\n")
                ws_bbc[f'M{bbc_row}'] = 2
                ws_bbc[f'N{bbc_row}'] = ags_times['P']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=2, M{bbc_row}={ags_times['P']} (规则 2)\n")
                continue
            else:
                ws_bbc[f'M{bbc_row}'] = None
                ws_bbc[f'N{bbc_row}'] = None
                update_output_text(output_text, f"规则 2 AGS O 未满足，清空 L{bbc_row} 和 M{bbc_row}，跳过本次循环\n")
                continue
        else:
            update_output_text(output_text, f"规则 2 BBC 条件未满足，继续检查下一规则\n")

        if bbc_values['I'] == 'No':
            if ags_times['K']:
                update_output_text(output_text, f"规则 3 匹配: AGS K={ags_times['K']}, BBC I='No'\n")
                ws_bbc[f'M{bbc_row}'] = 3
                ws_bbc[f'N{bbc_row}'] = ags_times['K']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=3, M{bbc_row}={ags_times['K']} (规则 3)\n")
                continue

        else:
            update_output_text(output_text, f"规则 3 BBC 条件未满足，继续检查下一规则\n")

        if bbc_values['J'] == 'No':
            if ags_times['L']:
                update_output_text(output_text, f"规则 4 匹配: AGS L={ags_times['L']}, BBC J='No'\n")
                ws_bbc[f'M{bbc_row}'] = 4
                ws_bbc[f'N{bbc_row}'] = ags_times['L']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=4, M{bbc_row}={ags_times['L']} (规则 4)\n")
                continue
        else:
            update_output_text(output_text, f"规则 4 BBC 条件未满足，继续检查下一规则\n")

        if bbc_values['K'] == 'No':
            if ags_times['M']:
                update_output_text(output_text, f"规则 5 匹配: AGS M={ags_times['M']}, BBC K='No'\n")
                ws_bbc[f'M{bbc_row}'] = 5
                ws_bbc[f'N{bbc_row}'] = ags_times['M']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=5, M{bbc_row}={ags_times['M']} (规则 5)\n")
                continue
        else:
            update_output_text(output_text, f"规则 4 BBC 条件未满足，继续检查下一规则\n")

        if bbc_values['L'] == 'No':
            if ags_times['N']:
                update_output_text(output_text, f"规则 5 匹配: AGS N={ags_times['N']}, BBC L='No'\n")
                ws_bbc[f'M{bbc_row}'] = 6
                ws_bbc[f'N{bbc_row}'] = ags_times['N']
                update_output_text(output_text, f"写入 BBC L{bbc_row}=6, M{bbc_row}={ags_times['N']} (规则 6)\n")
                continue
        else:
            ws_bbc[f'M{bbc_row}'] = "目前无可做节点请检查"
            ws_bbc[f'N{bbc_row}'] = "目前无可做节点请检查"

        update_output_text(output_text, f"参数 {param} 处理完成\n")

    # 保存 BBC 文件
    red_fill = PatternFill(start_color="FFFF0000", end_color="FFFF0000", fill_type="solid")

    current_time = datetime.now()

    # 遍历 M 列（第13列），从第2行开始
    for row in ws_bbc.iter_rows(min_row=2, min_col=14, max_col=14):
        cell = row[0]

        if not cell.value:
            continue  # 跳过空值

        # 如果是字符串，尝试解析为 datetime
        if isinstance(cell.value, str):
            try:
                cell.value = parser.parse(cell.value.strip())
            except:
                continue  # 解析失败，跳过

        # 现在确保是 datetime 类型
        if not isinstance(cell.value, datetime):
            continue  # 不是 datetime，跳过

        # 设置时间格式
        cell.number_format = 'YYYY-MM-DD HH:MM:SS'

        # 判断是否超过 24 小时
        if cell.value < current_time - timedelta(hours=25):
            cell.fill = red_fill

    # 保存文件
    wb_bbc.save(file_path_bbc)
    update_output_text(output_text, "处理完成，BBCreview.xlsx 已保存\n")

def daily_report(output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "dailyreport.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到所需的excel\n")
            pass
        else:
            # 创建空的 Excel 文件
            update_output_text(output_text, "未找到所需的excel已创建，请再次点击开始\n")

            wb = Workbook()
            wb.save(file_path)
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():
        try:
            txt_file_path = os.path.join(desktop_path, "output.txt")
            if os.path.exists(txt_file_path):
                with open(txt_file_path, 'r', encoding='utf-8') as txt_file:
                    data = json.load(txt_file)
                    return data.get("cookies", {}), data.get("xsrf_token", None)
            else:
                update_output_text(output_text, "未找到output.txt\n")
                return {}, None
        except Exception as e:
            update_output_text(output_text, f"读取文本文件出错: {e}\n")
            return {}, None

    def get_api_response(awbnum):
        # 目标 URL
        url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/manifest/queryPage"

        # 获取动态 Cookie 和 XSRF-TOKEN
        cookies, xsrf_token = read_cookies_from_txt()

        # 验证 XSRF-TOKEN 是否存在
        if not xsrf_token:
            update_output_text(output_text, "错误：未找到 XSRF-TOKEN，请确认登录成功\n")
            return "N/A"

        # 动态构建 headers
        headers = {
            "Content-Type": "application/json",
            "X-Xsrf-Token": xsrf_token,
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Origin": "https://os.gcsp.cainiao-inc.com",
            "Referer": "https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestlist",
            "Bx-V": "2.5.31",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin"
        }

        # 动态计算时间（明天前30天到明天）
        tomorrow = datetime.now() + timedelta(days=1)
        thirty_days_ago = tomorrow - timedelta(days=30)

        # 格式化时间
        createTimeBegin = thirty_days_ago.strftime("%d-%m-%Y 00:00:00")
        createTimeEnd = tomorrow.strftime("%d-%m-%Y 00:00:00")
        createTimeStr = [
            thirty_days_ago.strftime("%Y-%m-%dT00:00:00.000Z"),
            tomorrow.strftime("%Y-%m-%dT00:00:00.000Z")
        ]

        # 构建 payload
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "linehualCode": awbnum,
            "createTimeBegin": createTimeBegin,
            "createTimeEnd": createTimeEnd,
            "createTimeStr": createTimeStr,
            "etaTimeBegin": "",
            "etaTimeEnd": ""
        }

        try:
            # 发送 POST 请求
            response = requests.post(url, headers=headers, cookies=cookies, json=payload)
            response.raise_for_status()  # 检查请求是否成功

            # 处理响应
            data = response.json()
            # 提取 mfCode
            mf_code = data.get('data', {}).get('tableData', [{}])[0].get('mfCode', 'N/A')
            if mf_code == 'N/A':
                update_output_text(output_text, "错误：响应中未找到 mfCode\n")
            else:
                update_output_text(output_text, f"请求成功！mfCode：{mf_code}\n")
            return mf_code

        except requests.RequestException as e:
            update_output_text(output_text, f"请求失败，错误信息：{e}\n")
            return "N/A"
        except ValueError as e:
            update_output_text(output_text, f"JSON 解析错误：{e}\n")
            return "N/A"
        except (KeyError, IndexError) as e:
            update_output_text(output_text, f"提取 mfCode 失败，数据结构错误：{e}\n")
            return "N/A"

    def get_post_history(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/log/pageQuery"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "businessCode": mfcode,
                "businessType": "MANIFEST",
                "pageNo": 1,
                "pageSize": 10
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")


    def get_all_amount(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/parcel/queryPage"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "ccStatusCode": "",
                "mainOrderCode": mfcode,
                "pageNo": 1,
                "pageSize": 10
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def get_qty_history(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/manifest/getParcelStatusTotal"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "mainOrderCode": mfcode
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def generate_manifest_summary(post_history, qty_history, total_amount):
        # Initialize result list
        result = []

        # 1. 提取总数量 (total_count)
        try:
            total_amount_count = total_amount['data']['paging']['totalCount'] if total_amount and isinstance(
                total_amount, dict) else "N/A"
        except (KeyError, TypeError):
            total_amount_count = "N/A"
        result.append(total_amount_count)

        # 2. 提取派送数量 (HANDOVER count)
        # 注意：qty_history 中状态码通常是准确且固定的，这里保持只匹配 'HANDOVER'
        try:
            handover_count = next((item['count'] for item in qty_history['data'] if item['status'] == 'HANDOVER'),
                                  0) if qty_history and isinstance(qty_history, dict) else "N/A"
        except (KeyError, TypeError, StopIteration):
            handover_count = "N/A"
        result.append(handover_count)

        # 3. 提取放行数量 (CC_RELEASE count)
        try:
            cc_release_count = next((item['count'] for item in qty_history['data'] if item['status'] == 'CC_RELEASE'),
                                    0) if qty_history and isinstance(qty_history, dict) else "N/A"
        except (KeyError, TypeError, StopIteration):
            cc_release_count = "N/A"
        result.append(cc_release_count)

        # 4. 提取最新的包含 'HANDOVER' 的时间并格式化
        handover_time_str = "N/A"
        try:
            # post_history.get('data', {}).get('tableData', []) 默认按时间倒序排列 (最新的在前面)
            # 寻找第一个 'code' 包含 'HANDOVER' 字符串的条目
            handover_entry = next((item for item in post_history.get('data', {}).get('tableData', [])
                                   if 'HANDOVER' in item.get('code', '')), None)

            if handover_entry:
                # 使用 operateTime 字段（毫秒时间戳）
                operate_time_ms = handover_entry.get('operateTime')
                if operate_time_ms:
                    # 毫秒转秒
                    operate_time_s = operate_time_ms / 1000
                    # 转换为 datetime 对象
                    # 注意：如果时间戳已经是当地时间，可能不需要进一步调整时区。
                    # 考虑到 API 返回的数据结构和实际应用，假设它是 UTC 或已经处理过的时区，直接转换为本地时间。
                    dt_object = datetime.fromtimestamp(operate_time_s)
                    # 格式化为 'YYYY/MM/DD HH:MM:SS'
                    handover_time_str = dt_object.strftime('%Y/%m/%d %H:%M:%S')

        except Exception:
            handover_time_str = "N/A"

        result.append(handover_time_str)

        return result

    def main_function():
        # 加载 Excel 文件
        try:
            wb = openpyxl.load_workbook(file_path)
            ws = wb.active

            # 检查第一行是否已有表头（以 A1 是否有值或是否为 '原始awb' 为例）
            has_header = ws['A1'].value is not None  # 简单判断：如果 A1 不为空，假设有表头

            # 如果没有表头，插入新行并添加新的表头
            if not has_header:
                ws.insert_rows(1)
                ws['A1'] = '原始awb'
                ws['B1'] = 'MFCODE'  # 调整为 B1
                ws['C1'] = 'awb'  # 调整为 C1
                ws['D1'] = '总数量'
                ws['E1'] = '派送数量'
                ws['F1'] = '放行数量'
                ws['G1'] = '最新HANDOVER时间'  # 新增的列

            # 提取第一列数据（跳过表头）
            first_column_values = [ws.cell(row=row, column=1).value for row in range(2, ws.max_row + 1) if
                                   ws.cell(row=row, column=1).value is not None]

            # 处理每个 AWB 并写入结果
            for idx, awb in enumerate(first_column_values, start=2):  # 从第 2 行开始
                mfcode = get_api_response(awb)
                # 只需要 post_history, qty_history, total_amount
                post_history = get_post_history(mfcode)
                qty_history = get_qty_history(mfcode)
                total_amount = get_all_amount(mfcode)
                # 移除 inoutbound_status 的调用，因为 generate_manifest_summary 不再使用它

                # 调整 generate_manifest_summary 的调用参数
                final_list = generate_manifest_summary(post_history, qty_history, total_amount)

                # 写入 MFCODE 到 B 列
                ws[f'B{idx}'] = mfcode
                # 写入 AWB 到 C 列
                ws[f'C{idx}'] = awb

                # 写入结果到 D 列开始
                # final_list 包含：[总数量, 派送数量, 放行数量, 最新HANDOVER时间]
                # 它们对应 Excel 的 D, E, F, G 列
                for col_idx, value in enumerate(final_list, start=4):  # 从 D 列（第 4 列）开始
                    ws[f'{get_column_letter(col_idx)}{idx}'] = value

                update_output_text(output_text, f'{awb} 运行完成\n')

            # 保存修改后的工作簿
            wb.save(file_path)
            update_output_text(output_text, "文件处理完成并保存\n")

        except FileNotFoundError:
            update_output_text(output_text, f"错误：文件 {file_path} 不存在！\n")
        except Exception as e:
            update_output_text(output_text, f"发生错误：{e}\n")

    main_function()





def node_update(output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到BBCreview\n")
            pass
        else:
            # 创建空的 Excel 文件
            update_output_text(output_text, '错误没能找到BBCreview')
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止

    wb_bbc = openpyxl.load_workbook(file_path)
    ws_bbc = wb_bbc.active  # 获取活动工作表

    # 字典存储 A:[B,L,M]
    data_dict = {}

    # 提取 A、B、L、M 列（列索引分别为 1、2、12、13，假设从 1 开始）
    for row in ws_bbc.iter_rows(min_row=2, max_col=14):  # 从第 2 行开始，跳过表头
        a_value = row[0].value  # A 列
        b_value = row[1].value  # B 列
        m_value = row[12].value  # L 列
        n_value = row[13].value  # M 列
        if a_value:  # 确保 A 列有值
            data_dict[a_value] = [b_value, m_value, n_value]

    def read_cookies_from_txt():
        try:
            txt_file_path = os.path.join(desktop_path, "output.txt")
            if os.path.exists(txt_file_path):
                with open(txt_file_path, 'r', encoding='utf-8') as txt_file:
                    data = json.load(txt_file)
                    return data.get("cookies", {}), data.get("xsrf_token", None)
            else:
                update_output_text(output_text, "未找到output.txt\n")
                return {}, None
        except Exception as e:
            update_output_text(output_text, f"读取文本文件出错: {e}")
            return {}, None

    def generate_payload_type1(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "INBOUND",
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN"
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    def generate_payload_type2(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "OUTBOUND",
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN"
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    # 定义生成 payload 的函数（L=3）
    def generate_payload_type3(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "PARTIAL_HANDOVER",
            "partialIdType": "LAST_MILE_ID",
            "lastmileResourceList": ["DISTRIBUTOR_31113738"],
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN",
            "lastmileResourceNameList": ["UNIUNI末端配送"]
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    def generate_payload_type4(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "PARTIAL_HANDOVER",
            "partialIdType": "LAST_MILE_ID",
            "lastmileResourceList": ["DISTRIBUTOR_31314278"],
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN",
            "lastmileResourceNameList": ["美国统包标准配送资源"]
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    def generate_payload_type5(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "PARTIAL_HANDOVER",
            "partialIdType": "LAST_MILE_ID",
            "lastmileResourceList": ["DISTRIBUTOR_31414492"],
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN",
            "lastmileResourceNameList": ["美国USPS直连末端配送"]
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    def generate_payload_type6(b_value, n_value):
        param_dict = {
            "operateTime": n_value.strftime('%Y-%m-%d %H:%M:%S') if isinstance(n_value, datetime) else str(n_value),
            "operateTimeZone": "America/Los_Angeles",
            "status": "PARTIAL_HANDOVER",
            "partialIdType": "LAST_MILE_ID",
            "lastmileResourceList": ["DISTRIBUTOR_31624738"],
            "mainOrderCode": b_value,
            "bigBagIdList": [],
            "testMode": "false",
            "domain": "USA",
            "lang": "zh-CN",
            "lastmileResourceNameList": ["MAERSK-末端配送"]
        }
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "handler": "selfServiceUsaManifestUpdateHandler",
            "param": json.dumps(param_dict, ensure_ascii=False, separators=(',', ':')),
            "type": "NONE"
        }
        return payload

    def upload_payloads(payloads):

        cookies, xsrf_token = read_cookies_from_txt()

        url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/asyncTask/createTask"

        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
            "Bx-V": "2.5.31",
            "Content-Type": "application/json",
            "Origin": "https://os.gcsp.cainiao-inc.com",
            "Priority": "u=1, i",
            "Referer": "https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode=CB10009939547545",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "x-csrf-token": xsrf_token,
            "X-Xsrf-Token": xsrf_token
        }

        responses = []

        for payload in payloads:
            try:
                response = requests.post(
                    url,
                    headers=headers,
                    cookies=cookies,
                    data=json.dumps(payload),
                    timeout=10
                )
                response.raise_for_status()  # 抛出异常如果状态码不是 200
                responses.append({
                    "status": response.status_code,
                    "content": response.json() if response.content else {},
                    "payload": payload
                })
            except requests.exceptions.RequestException as e:
                responses.append({
                    "status": "error",
                    "error": str(e),
                    "payload": payload
                })

        return responses

    current_time = datetime.now()

    # 生成 payload 列表
    payloads = []
    for a_value, (b_value, m_value, n_value) in data_dict.items():
        if n_value is not None and n_value < current_time - timedelta(hours=23):
            update_output_text(output_text, f'{a_value}时间超出24小时！！！无法上传')
        else:
            if m_value == 1:
                payload = generate_payload_type1(b_value, n_value)
                print(payload)
                payloads.append(payload)
            elif m_value == 2:
                payload = generate_payload_type2(b_value, n_value)
                update_output_text(output_text, payload)
                payloads.append(payload)
            elif m_value == 3:
                payload = generate_payload_type3(b_value, n_value)
                update_output_text(output_text, payload)
                payloads.append(payload)
            elif m_value == 4:
                payload = generate_payload_type4(b_value, n_value)
                update_output_text(output_text, payload)
                payloads.append(payload)
            elif m_value == 5:
                payload = generate_payload_type5(b_value, n_value)
                update_output_text(output_text, payload)
                payloads.append(payload)
            elif m_value == 6:
                payload = generate_payload_type6(b_value, n_value)
                update_output_text(output_text, payload)
                payloads.append(payload)

    results = upload_payloads(payloads)
    for result in results:
        update_output_text(output_text, result)
    update_output_text(output_text,'全部完成')
def node_status(output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到BBCreview\n")
            pass
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():
        try:
            txt_file_path = os.path.join(desktop_path, "output.txt")
            if os.path.exists(txt_file_path):
                with open(txt_file_path, 'r', encoding='utf-8') as txt_file:
                    data = json.load(txt_file)
                    return data.get("cookies", {}), data.get("xsrf_token", None)
            else:
                update_output_text(output_text, "未找到output.txt\n")
                return {}, None
        except Exception as e:
            update_output_text(output_text, f"读取文本文件出错: {e}\n")
            return {}, None

    def get_api_response(awbnum):
        # 目标 URL
        url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/manifest/queryPage"

        # 获取动态 Cookie 和 XSRF-TOKEN
        cookies, xsrf_token = read_cookies_from_txt()

        # 验证 XSRF-TOKEN 是否存在
        if not xsrf_token:
            update_output_text(output_text, "错误：未找到 XSRF-TOKEN，请确认登录成功\n")
            return "N/A"

        # 动态构建 headers
        headers = {
            "Content-Type": "application/json",
            "X-Xsrf-Token": xsrf_token,
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Origin": "https://os.gcsp.cainiao-inc.com",
            "Referer": "https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestlist",
            "Bx-V": "2.5.31",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin"
        }

        # 动态计算时间（明天前30天到明天）
        tomorrow = datetime.now() + timedelta(days=1)
        thirty_days_ago = tomorrow - timedelta(days=30)

        # 格式化时间
        createTimeBegin = thirty_days_ago.strftime("%d-%m-%Y 00:00:00")
        createTimeEnd = tomorrow.strftime("%d-%m-%Y 00:00:00")
        createTimeStr = [
            thirty_days_ago.strftime("%Y-%m-%dT00:00:00.000Z"),
            tomorrow.strftime("%Y-%m-%dT00:00:00.000Z")
        ]

        # 构建 payload
        payload = {
            "testMode": "false",
            "domain": "USA",
            "gateCode": "All",
            "linehualCode": awbnum,
            "createTimeBegin": createTimeBegin,
            "createTimeEnd": createTimeEnd,
            "createTimeStr": createTimeStr,
            "etaTimeBegin": "",
            "etaTimeEnd": ""
        }

        try:
            # 发送 POST 请求
            response = requests.post(url, headers=headers, cookies=cookies, json=payload)
            response.raise_for_status()  # 检查请求是否成功

            # 处理响应
            data = response.json()
            # 提取 mfCode
            mf_code = data.get('data', {}).get('tableData', [{}])[0].get('mfCode', 'N/A')
            if mf_code == 'N/A':
                update_output_text(output_text, "错误：响应中未找到 mfCode\n")
            else:
                update_output_text(output_text, f"请求成功！mfCode：{mf_code}\n")
            return mf_code

        except requests.RequestException as e:
            update_output_text(output_text, f"请求失败，错误信息：{e}\n")
            return "N/A"
        except ValueError as e:
            update_output_text(output_text, f"JSON 解析错误：{e}\n")
            return "N/A"
        except (KeyError, IndexError) as e:
            update_output_text(output_text, f"提取 mfCode 失败，数据结构错误：{e}\n")
            return "N/A"

    def get_post_history(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/log/pageQuery"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "businessCode": mfcode,
                "businessType": "MANIFEST",
                "pageNo": 1,
                "pageSize": 10
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def query_manifest_detail(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/manifest/queryDetail"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "mainOrderCode": mfcode
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def get_all_amount(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/parcel/queryPage"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "ccStatusCode": "",
                "mainOrderCode": mfcode,
                "pageNo": 1,
                "pageSize": 10
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def get_qty_history(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/manifest/getParcelStatusTotal"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "mainOrderCode": mfcode
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                # print(response.json())  # 已注释
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def inbound_outbound_status(mfcode):
        if mfcode == "N/A":
            return "N/A"
        else:
            cookies_dict, xsrf_token = read_cookies_from_txt()
            url = "https://os.gcsp.cainiao-inc.com/gcsp-buc/ggg3oc/log/timeline"
            headers = {
                "Accept": "application/json, text/plain, */*",
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Content-Type": "application/json",
                "Origin": "https://os.gcsp.cainiao-inc.com",
                "Priority": "u=1, i",
                "Referer": f"https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestdetail?mainOrderCode={mfcode}",
                "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
                "Sec-Ch-Ua-Mobile": "?0",
                "Sec-Ch-Ua-Platform": '"Windows"',
                "Sec-Fetch-Dest": "empty",
                "Sec-Fetch-Mode": "cors",
                "Sec-Fetch-Site": "same-origin",
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "X-Xsrf-Token": xsrf_token,
                "x-csrf-token": xsrf_token
            }
            payload = {
                "testMode": "false",
                "domain": "USA",
                "gateCode": "All",
                "businessCode": mfcode,
                "businessType": "MANIFEST"
            }
            response = requests.post(url, headers=headers, cookies=cookies_dict, json=payload)
            if response.status_code == 200:
                return response.json()
            else:
                raise Exception(f"Request failed with status {response.status_code}: {response.text}")

    def generate_manifest_summary(post_history, qty_history, total_amount, inoutbound_status):
        # Initialize result list
        result = []

        # Extract total_count from total_amount
        try:
            total_amount_count = total_amount['data']['paging']['totalCount'] if total_amount and isinstance(
                total_amount, dict) else "N/A"
        except (KeyError, TypeError):
            total_amount_count = "N/A"
        result.append(total_amount_count)

        # Check INBOUND status in inoutbound_status
        try:
            inbound_status = next((item['status'] for item in inoutbound_status['data'] if item['name'] == 'INBOUND'),
                                  'wait') if inoutbound_status and isinstance(inoutbound_status, dict) else "wait"
            inbound_count = 'Y' if inbound_status == 'finish' else 'N'
        except (KeyError, TypeError, StopIteration):
            inbound_count = 'N'
        result.append(inbound_count)

        # Check OUTBOUND status in inoutbound_status
        try:
            outbound_status = next((item['status'] for item in inoutbound_status['data'] if item['name'] == 'OUTBOUND'),
                                   'wait') if inoutbound_status and isinstance(inoutbound_status, dict) else "wait"
            outbound_count = 'Y' if outbound_status == 'finish' else 'N'
        except (KeyError, TypeError, StopIteration):
            outbound_count = 'N'
        result.append(outbound_count)

        # Extract counts from qty_history for specific statuses
        try:
            handover_count = next((item['count'] for item in qty_history['data'] if item['status'] == 'HANDOVER'),
                                  0) if qty_history and isinstance(qty_history, dict) else "N/A"
        except (KeyError, TypeError, StopIteration):
            handover_count = "N/A"
        result.append(handover_count)

        try:
            cc_release_count = next((item['count'] for item in qty_history['data'] if item['status'] == 'CC_RELEASE'),
                                    0) if qty_history and isinstance(qty_history, dict) else "N/A"
        except (KeyError, TypeError, StopIteration):
            cc_release_count = "N/A"
        result.append(cc_release_count)

        # Check for specific delivery resources in post_history
        try:
            uniuni_present = any('UNIUNI末端配送' in item['content'] for item in
                                 post_history['data']['tableData']) if post_history and isinstance(post_history,
                                                                                                   dict) else False
            result.append('Yes' if uniuni_present else 'No')
        except (KeyError, TypeError):
            result.append('N/A')

        try:
            us_standard_present = any('美国统包标准配送资源' in item['content'] for item in
                                      post_history['data']['tableData']) if post_history and isinstance(post_history,
                                                                                                        dict) else False
            result.append('Yes' if us_standard_present else 'No')
        except (KeyError, TypeError):
            result.append('N/A')

        try:
            usps_present = any('美国USPS直连末端配送' in item['content'] for item in
                               post_history['data']['tableData']) if post_history and isinstance(post_history,
                                                                                                 dict) else False
            result.append('Yes' if usps_present else 'No')
        except (KeyError, TypeError):
            result.append('N/A')
        try:
            usps_present = any('MAERSK-末端配送' in item['content'] for item in
                               post_history['data']['tableData']) if post_history and isinstance(post_history,
                                                                                                 dict) else False
            result.append('Yes' if usps_present else 'No')
        except (KeyError, TypeError):
            result.append('N/A')

        return result

    def main_function():
        # 加载 Excel 文件
        try:
            wb = openpyxl.load_workbook(file_path)
            ws = wb.active

            # 检查第一行是否已有表头（以 A1 是否有值或是否为 '原始awb' 为例）
            has_header = ws['A1'].value is not None  # 简单判断：如果 A1 不为空，假设有表头

            # 如果没有表头，插入新行并添加表头
            if not has_header:
                ws.insert_rows(1)
                ws['A1'] = '原始awb'
                ws['C1'] = 'awb'
                ws['D1'] = '总数量'
                ws['E1'] = '入库状态'
                ws['F1'] = '出库状态'
                ws['G1'] = '派送数量'
                ws['H1'] = '放行数量'
                ws['I1'] = 'uni'
                ws['J1'] = 'coe'
                ws['K1'] = 'usps'
                ws['L1'] = 'Maersk'
                ws['M1'] = '任务类型'
                ws['N1'] = '任务时间    '

            # 提取第一列数据（跳过表头）
            first_column_values = [ws.cell(row=row, column=1).value for row in range(2, ws.max_row + 1) if
                                   ws.cell(row=row, column=1).value is not None]

            # 处理每个 AWB 并写入结果
            for idx, awb in enumerate(first_column_values, start=2):  # 从第 2 行开始
                mfcode = get_api_response(awb)
                post_history = get_post_history(mfcode)
                qty_history = get_qty_history(mfcode)
                total_amount = get_all_amount(mfcode)
                inoutbound_status = inbound_outbound_status(mfcode)
                final_list = generate_manifest_summary(post_history, qty_history, total_amount, inoutbound_status)

                # 写入结果到 C 列到 K 列
                ws[f'C{idx}'] = awb  # 写入 AWB 到 C 列
                ws[f'B{idx}'] = mfcode
                for col_idx, value in enumerate(final_list, start=4):  # 从 D 列（第 4 列）开始
                    ws[f'{get_column_letter(col_idx)}{idx}'] = value

                update_output_text(output_text, f'{awb} 运行完成\n')

            # 保存修改后的工作簿
            wb.save(file_path)
            update_output_text(output_text, "文件处理完成并保存\n")

        except FileNotFoundError:
            update_output_text(output_text, f"错误：文件 {file_path} 不存在！\n")
        except Exception as e:
            update_output_text(output_text, f"发生错误：{e}\n")

    # 调用函数
    main_function()










































def node_token(account, password, output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        txt_file_path = os.path.join(desktop_path, "output.txt")
        if os.path.exists(txt_file_path):
            update_output_text(output_text, "已找到所需的cookie文件，即将继续运行\n\n")
            pass
        else:
            # 创建空的文本文件
            with open(txt_file_path, 'w', encoding='utf-8'):
                update_output_text(output_text, "未找到所需的cookie文件，现已创建，请再次点击运行\n\n")
                pass
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题


    # 启动 Chrome 浏览器
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://os.gcsp.cainiao-inc.com/USA/manifestlist/manifestlist"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="account"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.XPATH,
                                       "/html/body/div[1]/div/div[1]/div[2]/div[2]/div[2]/div/form/div[3]/div/button")
    login_button.click()
    update_output_text(output_text, "登录成功，等待标题变化中\n\n")

    initial_title = driver.title
    initial_url = driver.current_url

    update_output_text(output_text, f"Current page title: {driver.title}")

    def page_changed(t, u):
        def _pred(d): return d.title != t or d.current_url != u

        return _pred

    try:
        WebDriverWait(driver, 50).until(page_changed(initial_title, initial_url))
        update_output_text(output_text, f"Current page title is: {driver.title}")
    except Exception as e:
        update_output_text(output_text, f"登录失败或超时: {str(e)}")
        raise
    update_output_text(output_text, "检测到标题变化，即将获取token\n\n")

    def get_cookies_from_driver(driver):
        try:
            # 获取 Selenium 的 Cookie 列表
            selenium_cookies = driver.get_cookies()
            # 转换为 requests 库的 Cookie 字典
            cookies_dict = {cookie['name']: cookie['value'] for cookie in selenium_cookies}
            # 提取 XSRF-TOKEN（如果存在）
            xsrf_token = cookies_dict.get('XSRF-TOKEN', None)
            driver.quit()
            return cookies_dict, xsrf_token
        except Exception as e:
            update_output_text(output_text, f"没能正确获取cookie信息{e}。\n\n")
            driver.quit()
            return {}, None

    if desktop_path:
        txt_file_path = os.path.join(desktop_path, "output.txt")
        if not os.path.exists(txt_file_path):
            print("未找到output.txt\n")
            pass
        else:
            # 创建文本文件并写入 cookies_dict 和 xsrf_token
            cookies_dict, xsrf_token = get_cookies_from_driver(driver)
            with open(txt_file_path, 'w', encoding='utf-8') as txt_file:
                txt_file.write(json.dumps({"cookies": cookies_dict, "xsrf_token": xsrf_token}, ensure_ascii=False))
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止
    update_output_text(output_text, "已将临时的用户信息写入桌面的output记事本\n\n")


def email_token(account, password, output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")
        if os.path.exists(txt_file_path):
            update_output_text(output_text, "已找到临时的email用户信息文件，即将继续代码\n\n")
            pass
        else:
            # 创建空的文本文件
            with open(txt_file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到临时的email用户信息文件，已创建，请再次点击运行\n\n")

            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立即停止

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题


    # 启动 Chrome 浏览器
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/inbox/all/eyJpZCI6IjJfMDpEenp6enlLemZ2QiQtLS0uZjlkRkZ6QyIsInR5cGUiOiJtYWlsIiwiaXNEcmFmdE1haWwiOmZhbHNlfQ"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="account"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.XPATH,
                                       "/html/body/div[1]/div/div[1]/div[2]/div[2]/div[2]/div/form/div[3]/div/button")
    login_button.click()
    update_output_text(output_text, "登录成功，等待标题变化中\n\n")

    initial_title = driver.title
    initial_url = driver.current_url

    update_output_text(output_text, f"Current page title: {driver.title}")

    def page_changed(t, u):
        def _pred(d): return d.title != t or d.current_url != u

        return _pred

    try:
        WebDriverWait(driver, 50).until(page_changed(initial_title, initial_url))
        update_output_text(output_text, f"Current page title is: {driver.title}")
    except Exception as e:
        update_output_text(output_text, f"登录失败或超时: {str(e)}")
        raise
    update_output_text(output_text, "检测到标题变化，即将获取token\n\n")

    def get_cookies_dict(driver):
        """从浏览器中提取登录信息（Cookies）"""
        try:
            cookies = driver.get_cookies()
            cookies_dict = {cookie['name']: cookie['value'] for cookie in cookies}
            update_output_text(output_text, f"[写入] 成功提取到 {len(cookies_dict)} 个登录信息")
            return cookies_dict
        except Exception as e:
            error_detail = str(e)
            update_output_text(output_text,
                               "获取登录信息失败，请检查是否已登录或网络正常\n"
                               f"【技术详情】{error_detail}"
                               )
            return {}

    def get_xsrf_token(driver):
        """智能查找安全校验码（xsrf_token）"""
        try:
            cookies = driver.get_cookies()

            # 策略1：从 Cookie 中找
            for cookie in cookies:
                name = cookie['name']
                normalized = name.lower().replace('_', '').replace('-', '')
                if normalized in ['xsrf_token', 'xsrftoken', '_csrf_token_', 'csrftoken', 'csrf_token']:
                    update_output_text(output_text, f"[写入] 从登录信息中找到安全校验码")
                    return cookie['value']

            # 策略2：从 meta 标签找
            try:
                meta = driver.find_element("css selector", "meta[name*='xsrf' i], meta[name*='csrf' i]")
                token = meta.get_attribute("content")

                if token:
                    update_output_text(output_text, f"[写入] 从网页标签中找到安全校验码")
                    return token
            except:
                pass  # 继续下一个策略

            # 策略3：正则搜索源码
            patterns = [
                r'"_?xsrf[-_]?token_?"\s*:\s*"([^"]+)"',
                r'"_?csrf[-_]?token_?"\s*:\s*"([^"]+)"',
                r'data-xsrf=["\']([^"\']+)["\']'
            ]
            for p in patterns:
                m = re.search(p, driver.page_source, re.I)
                if m:
                    update_output_text(output_text, f"[写入] 从网页源码中找到安全校验码")
                    return m.group(1)

            update_output_text(output_text, "[写入] 未找到安全校验码，将保存为空")
            return None

        except Exception as e:
            error_detail = str(e)
            update_output_text(output_text,
                               "查找安全校验码失败，可能是页面未加载完成\n"
                               f"【技术详情】{error_detail}"
                               )
            return None

    def save_cookies_and_token(driver, desktop_path):
        if not desktop_path:
            update_output_text(output_text, "保存路径未设置，跳过保存")
            return

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")
        update_output_text(output_text, f"\n=== 正在保存到桌面: emailtoken.txt ===")

        try:
            # 获取数据
            cookies_dict = get_cookies_dict(driver)
            xsrf_token = get_xsrf_token(driver)
            driver.quit()

            # 准备保存内容
            save_data = {
                "cookies": cookies_dict,
                "xsrf_token": xsrf_token
            }

            # 写入文件
            with open(txt_file_path, 'w', encoding='utf-8') as f:
                json.dump(save_data, f, ensure_ascii=False, indent=2)

            # 成功提示
            update_output_text(output_text, f"保存成功！文件路径：{txt_file_path}")
            update_output_text(output_text, f"   └─ 登录信息：{len(cookies_dict)} 条")
            token_preview = (xsrf_token[:50] + "..." if xsrf_token and len(xsrf_token) > 50 else xsrf_token) or "未获取到"
            update_output_text(output_text, f"   └─ 安全校验码：{token_preview}")

        except PermissionError as e:
            update_output_text(output_text,
                               "保存失败：没有权限写入桌面\n"
                               "请关闭占用 emailtoken.txt 的程序，或以管理员运行\n"
                               f"【技术详情】{str(e)}"
                               )
        except OSError as e:
            update_output_text(output_text,
                               "保存失败：磁盘空间不足或路径无效\n"
                               f"【技术详情】{str(e)}"
                               )
        except Exception as e:
            update_output_text(output_text,
                               "保存过程中出现未知错误，请重试\n"
                               f"【技术详情】{str(e)}"
                               )
        finally:
            update_output_text(output_text, "=== 保存操作已结束 ===\n")

    save_cookies_and_token(driver, desktop_path)
    update_output_text(output_text, "已经临时的email代码写入桌面文件\n\n")

    # 写入完成后可选择退出
    sys.exit()


def email_program(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "getemail.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件即将继续代码\n\n")

            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n\n")

            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n\n")

            return {}, None

        except Exception as e:
            update_output_text(output_text, f"{type(e).__name__}: {e}")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "0",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def read_cookies_from_txt():

        # 1. 打印 desktop_path 是否正确

        # 2. 拼接完整路径并打印
        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            return {}, None

        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                if len(raw_content) > 500:
                    print("...（内容过长，已截断）")

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:

            return {}, None

        except Exception as e:
            print(f"读取文本文件出错: {type(e).__name__}: {e}")
            return {}, None

        finally:
            print("=== 读取结束 ===\n")

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            print("cookies.txt 读取失败！")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            return response.json()  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        result = {
            "MAWB": "N/A",
            "FLIGHT NUMBER": "N/A",
            "ETA": "N/A",
            "NUMBER OF CTN": "N/A",
            "GROSS WEIGHT": "N/A",
            "QUANTITY OF PARCELS": "N/A",
            "美国统包标准配送资源": {
                "number of ctn": "N/A",
                "quantity of parcels": "N/A"
            }
        }

        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                    elif "Flight Number" in key:
                        result["FLIGHT NUMBER"] = raw_value
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value

        # === 2. 提取 distributor 模块：美国统包标准配送资源 ===
        distributor_tables = soup.find_all("table", align="center")
        target_distributor = None

        for table in distributor_tables:
            header = table.find("td", class_="distributorName")
            if header and "美国统包标准配送资源" in header.get_text(strip=True):
                target_distributor = table
                break

        if target_distributor:
            rows = target_distributor.find_all("tr")
            for row in rows[1:]:  # 跳过标题行
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                num_match = num_re.search(raw_value.replace(',', ''))
                value = num_match.group(0) if num_match else "N/A"

                if "Number of CTN" in key:
                    result["美国统包标准配送资源"]["number of ctn"] = value
                elif "Quantity of parcels" in key:
                    result["美国统包标准配送资源"]["quantity of parcels"] = value

        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 0
    for email_id in email_id_list[:int(limit_param)]:
        # 简洁提示：正在处理某封邮件

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 展平数据
            flat_info = {
                "MAWB": info.get("MAWB", "N/A"),
                "ETA": info.get("ETA", "N/A"),
                "FLIGHT NUMBER": info.get("FLIGHT NUMBER", "N/A"),
                "": "",
                "GROSS WEIGHT": info.get("GROSS WEIGHT", "N/A"),
                "QUANTITY OF PARCELS": info.get("QUANTITY OF PARCELS", "N/A"),
                "NUMBER OF CTN": info.get("NUMBER OF CTN", "N/A"),
                "美国统包标准配送资源_number_of_ctn": info["美国统包标准配送资源"].get("number of ctn", "N/A"),
                "美国统包标准配送资源_quantity_of_parcels": info["美国统包标准配送资源"].get("quantity of parcels",
                                                                                             "N/A"),
            }
            results.append(flat_info)
            processed_count += 1
            update_output_text(output_text, f"已处理 {processed_count} 个邮件\n")
        else:
            continue

    # ========= 表头（第1行）=========
    headers = [
        "MAWB",
        "ETA",
        "FLIGHT NUMBER",
        "ATA",
        "GROSS WEIGHT",
        "QUANTITY OF PARCELS",
        "NUMBER OF CTN",
        "美国统包标准配送资源_number_of_ctn",
        "美国统包标准配送资源_quantity_of_parcels"
    ]

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    df = pd.DataFrame(results, columns=headers)

    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")
def email_program_mia_AE(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "EMAIL-MIA-AE.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件即将继续代码\n\n")

            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n\n")

            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n\n")

            return {}, None

        except Exception as e:
            update_output_text(output_text, f"{type(e).__name__}: {e}")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "0",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def read_cookies_from_txt():

        # 1. 打印 desktop_path 是否正确

        # 2. 拼接完整路径并打印
        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            return {}, None

        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                if len(raw_content) > 500:
                    print("...（内容过长，已截断）")

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:

            return {}, None

        except Exception as e:
            print(f"读取文本文件出错: {type(e).__name__}: {e}")
            return {}, None

        finally:
            print("=== 读取结束 ===\n")

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            print("cookies.txt 读取失败！")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            return response.json()  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        result = {
            "MAWB": "N/A",
            "FLIGHT NUMBER": "N/A",
            "ETA": "N/A",
            # 新增所有需要的配送商的结构
            "DISTRIBUTORS": {
                "MAERSK-末端配送": {"number of ctn": "N/A", "quantity of parcels": "N/A"},
                "SpeedX配送": {"number of ctn": "N/A", "quantity of parcels": "N/A"},
                "UNIUNI末端配送": {"number of ctn": "N/A", "quantity of parcels": "N/A"},
                "美国统包标准配送资源": {"number of ctn": "N/A", "quantity of parcels": "N/A"},
                "美国USPS直连末端配送": {"number of ctn": "N/A", "quantity of parcels": "N/A"},
            }
        }

        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                    elif "Flight Number" in key:
                        result["FLIGHT NUMBER"] = raw_value
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value

        # === 2. 提取 distributor 模块：美国统包标准配送资源 ===
        distributor_tables = soup.find_all("table", align="center")
        target_distributors = result["DISTRIBUTORS"].keys()  # 所有目标配送商的名称

        for table in distributor_tables:
            header = table.find("td", class_="distributorName")
            if header:
                distributor_name = header.get_text(strip=True)
                # 检查是否是我们需要的配送商
                if distributor_name in target_distributors:
                    rows = table.find_all("tr")
                    for row in rows[1:]:  # 跳过标题行
                        tds = row.find_all("td")
                        if len(tds) != 2:
                            continue
                        key = tds[0].get_text(strip=True)
                        raw_value = tds[1].get_text(strip=True)

                        # 使用 try-except 确保数字提取不失败
                        try:
                            # 先去逗号，再尝试匹配数字，否则是 'N/A'
                            num_match = num_re.search(raw_value.replace(',', ''))
                            value = num_match.group(0) if num_match else "0"  # 提取失败或无数字时设为 0，方便求和
                        except:
                            value = "0"

                        if "Number of CTN" in key:
                            result["DISTRIBUTORS"][distributor_name]["number of ctn"] = value
                        elif "Quantity of parcels" in key:
                            result["DISTRIBUTORS"][distributor_name]["quantity of parcels"] = value

        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 1
    for email_id in email_id_list[:int(limit_param)]:
        # 简洁提示：正在处理某封邮件

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 展平数据
            distributors_info = info["DISTRIBUTORS"]
            total_ctn = 0
            total_parcel = 0

            # 提取数字并计算总和
            for dist_data in distributors_info.values():
                try:
                    total_ctn += float(dist_data["number of ctn"]) if dist_data["number of ctn"] != "N/A" else 0
                except ValueError:
                    pass  # 如果不是数字，跳过
                try:
                    total_parcel += float(dist_data["quantity of parcels"]) if dist_data[
                                                                                   "quantity of parcels"] != "N/A" else 0
                except ValueError:
                    pass  # 如果不是数字，跳过

            # 最终的展平数据结构（与 Excel 表头对应）
            flat_info = {
                "MAWB": info.get("MAWB", "N/A"),
                "UP": distributors_info["美国统包标准配送资源"].get("number of ctn", "N/A"),  # 假设 'UP' 对应 UNIUNI末端配送
                "USPS": distributors_info["美国USPS直连末端配送"].get("number of ctn", "N/A"),
                "UNIUNI": distributors_info["UNIUNI末端配送"].get("number of ctn", "N/A"),
                "SpeedX": distributors_info["SpeedX配送"].get("number of ctn", "N/A"),
                "Maersk": distributors_info["MAERSK-末端配送"].get("number of ctn", "N/A"),
                "total": str(int(total_ctn)),  # 箱数总和
                "parcel": str(int(total_parcel)),  # parcels总和
                "PMC": "",  # 留空
                "PMC return": "",  # 留空
                "1F": "",  # 留空
                "FLT#": info.get("FLIGHT NUMBER", "N/A"),
                "ETA": info.get("ETA", "N/A"),
            }
            results.append(flat_info)

            update_output_text(output_text, f"已完成{processed_count}封邮件\n")
            processed_count+=1
        else:
            continue

    # ========= 表头（第1行）=========
    headers = [
        "MAWB",
        "UP",
        "USPS",
        "UNIUNI",
        "SpeedX",
        "Maersk",
        "total",
        "parcel",
        "PMC",
        "PMC return",
        "1F",
        "FLT#",
        "ETA"
    ]

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    df = pd.DataFrame(results, columns=headers)

    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")

def email_program_mia_4px(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "EMAIL-MIA-4PX.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件，即将继续\n")
            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n")
            return {}, None

        except Exception as e:
            update_output_text(output_text, f"读取 cookie 失败: {type(e).__name__}: {e}\n")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "0",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            update_output_text(output_text, "cookies.txt 读取失败！\n")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            data = response.json()
            # 打印完整 JSON（邮件内容）
            try:
                print("[JSON-邮件内容] 以下为接口返回的完整 JSON：")
                print(json.dumps(data, ensure_ascii=False, indent=2))
            except Exception as e:
                print(f"[JSON-邮件内容] 打印失败: {e}")
            return data  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # 统一渠道顺序与别名映射（定义一次，全局复用）
    channel_order = ["COE", "GOFO", "SPX", "TOO", "USPS", "YANWEN"]

    # 内部使用的标准化渠道名称（用于提取结果字典中的键）
    internal_channel_keys = {
        "COE": "COE_KEY",
        "GOFO": "GOFO",
        "SPX": "SPX",
        "TOO": "TE",  # 保持内部使用 TE 来匹配 TOOEXPRESS/TOOEXPRESS-DF
        "USPS": "USPS",
        "YANWEN": "YW EXP",  # 保持内部使用 YW EXP 来匹配 YW EXPRESS
    }

    # 使用“规范化键”：全部小写、去空格与连字符，提升匹配鲁棒性
    exact_match_to_std = {
        "GOFO": "GOFO",
        "YW EXPRESS": "YW EXP",
        "TOOEXPRESS": "TE",
        "TOOEXPRESS-DF": "TE",  # TE-DF 合并到 TE
        "SPX": "SPX",
        "USPS-GA": "USPS",
        "COE": "COE_KEY",  # 统一使用 COE_KEY 来表示 COE/UP
    }
    # 移除包含匹配，只保留需要的
    contains_match_to_std = {
        # 移除了所有 ATL- 渠道
    }

    # 辅助函数，将内部使用的键映射回最终的表头名称
    def get_output_channel_name(internal_key):
        for output_name, internal_name in internal_channel_keys.items():
            if internal_name == internal_key:
                return output_name
        return internal_key  # 如果不是目标渠道，返回原键

    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        try:
            print("[extract_flight_info] 开始解析航班信息")
        except Exception:
            pass

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        # 使用统一的渠道顺序与别名映射（channel_order, alias_to_standard）

        result = {
            "MAWB": "N/A",
            "FLIGHT NUMBER": "N/A",
            "ETA": "N/A",
            "NUMBER OF CTN": "N/A",
            "GROSS WEIGHT": "N/A",
            "QUANTITY OF PARCELS": "N/A",
            "BUP": "N/A",
            "美国统包标准配送资源": {
                "number of ctn": "N/A",
                "quantity of parcels": "N/A"
            },
            # 预留 COE 组合输出
            "COE (Parcels/CTNS)": "N/A",
        }

        # 初始化渠道默认值（不包含 COE/UP）
        for ch in channel_order:
            result[ch] = "N/A"
        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            try:
                print(f"[解析主表] 找到主表，行数={len(main_table.find_all('tr'))}")
            except Exception:
                pass
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                try:
                    print(f"[主表行] key='{key}' value_raw='{raw_value}'")
                except Exception:
                    pass

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                    try:
                        print(f"[主表解析] ETA='{result['ETA']}'")
                    except Exception:
                        pass
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                        try:
                            print(f"[主表解析] MAWB='{result['MAWB']}'")
                        except Exception:
                            pass
                    elif "Flight Number" in key:
                        result["FLIGHT NUMBER"] = raw_value
                        try:
                            print(f"[主表解析] FLIGHT NUMBER='{result['FLIGHT NUMBER']}'")
                        except Exception:
                            pass
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                        try:
                            print(f"[主表解析] NUMBER OF CTN='{result['NUMBER OF CTN']}'")
                        except Exception:
                            pass
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                        try:
                            print(f"[主表解析] GROSS WEIGHT='{result['GROSS WEIGHT']}'")
                        except Exception:
                            pass
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value
                        try:
                            print(f"[主表解析] QUANTITY OF PARCELS='{result['QUANTITY OF PARCELS']}'")
                        except Exception:
                            pass

        # === 2. 提取 distributor 模块：美国统包标准配送资源 ===
        distributor_tables = soup.find_all("table", align="center")
        target_distributor = None

        for table in distributor_tables:
            header = table.find("td", class_="distributorName")
            if header and "美国统包标准配送资源" in header.get_text(strip=True):
                target_distributor = table
                break

        if target_distributor:
            try:
                print("[解析统包] 开始解析 '美国统包标准配送资源' 模块")
            except Exception:
                pass
            rows = target_distributor.find_all("tr")
            for row in rows[1:]:  # 跳过标题行
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                num_match = num_re.search(raw_value.replace(',', ''))
                value = num_match.group(0) if num_match else "N/A"

                if "Number of CTN" in key:
                    result["美国统包标准配送资源"]["number of ctn"] = value
                    try:
                        print(f"[解析统包] number of ctn='{value}'")
                    except Exception:
                        pass
                elif "Quantity of parcels" in key:
                    result["美国统包标准配送资源"]["quantity of parcels"] = value
                    try:
                        print(f"[解析统包] quantity of parcels='{value}'")
                    except Exception:
                        pass

        # === 3. 提取 "The MAWB is BUP" 中的 BUP 值 ===
        try:
            all_text = " ".join(soup.stripped_strings)
            m = re.search(r"The\s+MAWB\s+is\s*([A-Za-z0-9\-_/]+)", all_text, flags=re.IGNORECASE)
            if m:
                result["BUP"] = m.group(1)
                try:
                    print(f"[BUP识别] 值='{result['BUP']}'")
                except Exception:
                    pass
            else:
                # 退化方案：在包含该短语的标签中查找后续文本
                node = soup.find(string=re.compile(r"The\s+MAWB\s+is", re.IGNORECASE))
                if node:
                    next_text = node.parent.get_text(strip=True)
                    m2 = re.search(r"The\s+MAWB\s+is\s*([A-Za-z0-9\-_/]+)", next_text, flags=re.IGNORECASE)
                    if m2:
                        result["BUP"] = m2.group(1)
                        try:
                            print(f"[BUP识别-退化] 值='{result['BUP']}'")
                        except Exception:
                            pass
        except Exception:
            pass

        # === 4. 提取渠道 CTN：按行首单元格匹配渠道，第二列为 CTN ===
        unmatched_cells = []  # 用来收集未匹配的 <td> 内容
        try:
            tables = soup.find_all("table")
            try:
                print(f"[渠道扫描] 共{len(tables)}个表")
            except Exception:
                pass

            for ti, table in enumerate(tables, start=1):
                rows = table.find_all("tr")
                for ri, row in enumerate(rows, start=1):
                    tds = row.find_all("td")
                    if len(tds) < 2:
                        continue

                    raw_first = tds[0].get_text(strip=True).strip()
                    if not raw_first:
                        continue

                    # 过滤主表标题行
                    if any(keyword in raw_first for keyword in [
                        "MAWB", "Flight", "origin", "destination", "ETD", "ETA",
                        "Number of CTN", "Gross Weight", "Quantity", "parcels"
                    ]):
                        print(f"[跳过主表标题] 原文='{raw_first}'")
                        continue

                    # ---------- 1. 完全匹配 ----------
                    std = exact_match_to_std.get(raw_first)  # 完全相等
                    match_type = "exact" if std else None

                    # ---------- 2. 包含匹配 ----------
                    if not std:
                        for keyword, target in contains_match_to_std.items():
                            if keyword in raw_first:
                                std = target
                                match_type = "contains"
                                break

                    # ---------- 3. 没匹配到 → 记录 ----------
                    if not std:
                        unmatched_cells.append(raw_first)
                        try:
                            print(f"[渠道未识别] 表{ti}行{ri} 原文='{raw_first}'")
                        except Exception:
                            pass
                        continue

                    # ---------- 4. 标题/说明行过滤（可选） ----------
                    if re.search(r"(媒体|渠道)", raw_first):
                        try:
                            print(f"[可能标题/说明] 表{ti}行{ri} 原文='{raw_first}' → 匹配为'{std}'")
                        except Exception:
                            pass

                    # ---------- 5. COE/UP 组合 ----------
                    if std == "COE_KEY":
                        # COE 渠道需要同时提取 Parcels (tds[2]) 和 CTN (tds[1])
                        ctn_cell = tds[1].get_text(strip=True)
                        parcels_cell = tds[2].get_text(strip=True) if len(tds) >= 3 else ""

                        # CTN 提取 (需要定义 safe_int 在这个函数内部或全局)
                        def to_int(s):
                            try:
                                return int(str(s).replace(',', '').strip())
                            except Exception:
                                return 0

                        ctn_num_match = (num_re.search(ctn_cell.replace(',', '')) or re.search(r"\d+", ctn_cell))
                        new_ctn_val = ctn_num_match.group(0) if ctn_num_match else "0"

                        parcels_num_match = (
                                    num_re.search(parcels_cell.replace(',', '')) or re.search(r"\d+", parcels_cell))
                        new_parcels_val = parcels_num_match.group(0) if parcels_num_match else "0"

                        # --- 关键：累加 COE_CTN ---
                        old_ctn_sum = to_int(result.get("COE_CTN", "0"))
                        result["COE_CTN"] = str(old_ctn_sum + to_int(new_ctn_val))

                        # --- 关键：累加 COE_PARCELS ---
                        old_parcels_sum = to_int(result.get("COE_PARCELS", "0"))
                        result["COE_PARCELS"] = str(old_parcels_sum + to_int(new_parcels_val))


                        continue

                    # ---------- 6. 普通渠道 CTN ----------
                    ctn_cell = tds[1].get_text(strip=True)
                    num_match = num_re.search(ctn_cell.replace(',', ''))
                    new_value_str = num_match.group(0) if num_match else (ctn_cell if ctn_cell else "N/A")

                    def to_int(s):
                        try:
                            s_clean = str(s).replace(',', '').strip()
                            if s_clean.isdigit():
                                return int(s_clean)
                            m = re.search(r"\d+", s_clean)
                            return int(m.group(0)) if m else None
                        except Exception:
                            return None

                    old_value_str = result.get(std, "N/A")
                    old_n = to_int(old_value_str)
                    new_n = to_int(new_value_str)

                    # === 合并 TE 和 TE-DF ===
                    if std == "TE-DF":
                        # 转为 TE 并累加
                        std = "TE"  # 强制映射为 TE
                        old_value_str = result.get("TE", "N/A")
                        old_n = to_int(old_value_str)

                    # === 正常合并逻辑 ===
                    chosen_str = old_value_str
                    if old_n is None and new_n is not None:
                        chosen_str = str(new_n)
                    elif old_n is not None and new_n is None:
                        chosen_str = str(old_n)
                    elif old_n is not None and new_n is not None:
                        chosen_str = str(old_n + new_n)  # 关键：相加！
                    else:
                        if str(old_value_str).upper() == "N/A" and str(new_value_str).strip():
                            chosen_str = new_value_str

                    # 最终写入合并后的 TE（TE-DF 已消失）
                    result[std] = chosen_str

                    try:
                        print(
                            f"[渠道识别] 表{ti}行{ri} 标准='{std}' 原文='{raw_first}' 匹配方式='{match_type}' "
                            f"第二列='{ctn_cell}' 旧='{old_value_str}' 新='{new_value_str}' => 取='{chosen_str}'"
                        )
                    except Exception:
                        pass

        except Exception as e:
            print(f"[渠道提取异常] {e}")

        # 把未匹配的单元格内容放进结果（后面写 Excel 时取）
        result["未识别渠道"] = " | ".join(unmatched_cells) if unmatched_cells else "N/A"
        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 0
    for email_id in email_id_list[:int(limit_param)]:

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 渠道汇总调试打印：按既定顺序输出各渠道的最终值
            try:
                summary = {ch: info.get(ch, 'N/A') for ch in channel_order}
                print(f"[渠道汇总] {summary}")
                print(f"[UNI最终值] {info.get('UNI', 'N/A')}")
            except Exception:
                pass

            # 展平数据：按你指定的头部顺序
            def safe_int(s):
                try:
                    return int(str(s).replace(',', '').strip())
                except (ValueError, TypeError):
                    return 0

            # 内部渠道键到最终输出渠道名的映射
            channel_map = {
                "COE_KEY": "COE",  # 内部提取时使用 COE_KEY, 输出时用 COE
                "GOFO": "GOFO",
                "SPX": "SPX",
                "TE": "TOO",
                "USPS": "USPS",
                "YW EXP": "YANWEN",
            }

            # --- 1. 计算 CTN 总和 (COE, GOFO, SPX, TOO, USPS 的 CTN) ---
            total_ctn = 0
            # 渠道 CTN 键列表 (用于求和)
            ctn_sum_keys = ["COE_CTN", "GOFO", "SPX", "TE", "USPS"]

            for key in ctn_sum_keys:
                # COE 的 CTN 存在 COE_CTN 键中，其他渠道的 CTN 存在其标准键中
                ctn_val = info.get(key, "0")
                total_ctn += safe_int(ctn_val)

            # --- 2. 计算 Parcels 总和 (COE 的 Parcels) ---
            # 根据您的要求，只对 COE 渠道提取 Parcels 并求和
            total_parcels = safe_int(info.get("COE_PARCELS", "0"))

            # --- 3. 展平数据：按新的表头顺序 ---
            flat_info = {
                # 第一列：未识别渠道
                "未识别渠道": info.get("未识别渠道", "N/A"),
                # 主信息
                "MAWB": info.get("MAWB", "N/A"),
                "FLT#": info.get("FLIGHT NUMBER", "N/A"),
                "ETA": info.get("ETA", "N/A"),
                # 渠道 CTN (只展示 number of ctn)
                "COE": info.get("COE_CTN", "N/A"),  # 使用 COE_CTN 键
                "GOFO": info.get("GOFO", "N/A"),
                "SPX": info.get("SPX", "N/A"),
                "TOO": info.get("TE", "N/A"),
                "USPS": info.get("USPS", "N/A"),
                "YANWEN": info.get("YW EXP", "N/A"),
                # 求和结果
                "total CTN": str(total_ctn),
                "parcel": str(total_parcels),
                # 留空列
                "PMC": "",
                "PMC return": "",
            }

            results.append(flat_info)
            processed_count += 1
            update_output_text(output_text, f"已处理 {processed_count} 个邮件\n")
        else:
            continue

    # ========= 表头（第1行）=========
    # 最终表头（按你给定的顺序与命名）
    header_keys = [
        "未识别渠道", "MAWB",
        "COE", "GOFO", "SPX", "TOO", "USPS", "YANWEN",  # 渠道 CTN
        "total CTN", "parcel",  # 总和
        "PMC", "PMC return",  # 留空
        "FLT#", "ETA"  # 航班信息
    ]

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    # 确保 DataFrame 的列顺序与 header_keys 一致
    df = pd.DataFrame(results, columns=header_keys)

    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")




def wipe_off_lax(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "getemailord.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件，即将继续\n")
            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n")
            return {}, None

        except Exception as e:
            update_output_text(output_text, f"读取 cookie 失败: {type(e).__name__}: {e}\n")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "0",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            update_output_text(output_text, "cookies.txt 读取失败！\n")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            data = response.json()
            # 打印完整 JSON（邮件内容）
            try:
                print("[JSON-邮件内容] 以下为接口返回的完整 JSON：")
                print(json.dumps(data, ensure_ascii=False, indent=2))
            except Exception as e:
                print(f"[JSON-邮件内容] 打印失败: {e}")
            return data  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # 统一渠道顺序与别名映射（定义一次，全局复用）
    channel_order = [
        "COE/UP", "DHLe", "SPX", "ACI", "USPS", "IB", "FEDEX", "GOFO", "TOO", "UNIUNI","OC UNIUNI","YW EXP"
    ]
    # 使用“规范化键”：全部小写、去空格与连字符，提升匹配鲁棒性
    exact_match_to_std = {
        "GOFO": "GOFO",
        "TOOEXPRESS": "TE",
        "TOOEXPRESS-DF": "TE",  # ← 改为映射到 TE
        "UNIUNI": "UNI",
        "OC-UNI": "OC-UNI",
        "DHL": "DHL",
        "IB": "IB",
        "SPX": "SPX",
        "ACI": "ACI",
        "FEDEX GROUND": "FEDEX",
        "USPS-GA": "USPS",
        "COE": "COE/UP",
        "YW EXPRESS": "YW EXP",
    }

    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        try:
            print("[extract_flight_info] 开始解析航班信息")
        except Exception:
            pass

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        # 使用统一的渠道顺序与别名映射（channel_order, alias_to_standard）

        result = {
            "MAWB": "N/A",
            "ETA": "N/A",
            "NUMBER OF CTN": "N/A",
            "GROSS WEIGHT": "N/A",
            "QUANTITY OF PARCELS": "N/A",
            "未识别渠道": "N/A",
        }

        # 初始化渠道默认值（不包含 COE/UP）
        for ch in channel_order:
            result[f"{ch}_CTN"] = "N/A"
            result[f"{ch}_PARCELS"] = "N/A"
            result[f"{ch}_WEIGHT"] = "N/A"
        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            try:
                print(f"[解析主表] 找到主表，行数={len(main_table.find_all('tr'))}")
            except Exception:
                pass
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                try:
                    print(f"[主表行] key='{key}' value_raw='{raw_value}'")
                except Exception:
                    pass

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                    try:
                        print(f"[主表解析] ETA='{result['ETA']}'")
                    except Exception:
                        pass
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                        try:
                            print(f"[主表解析] MAWB='{result['MAWB']}'")
                        except Exception:
                            pass
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                        try:
                            print(f"[主表解析] NUMBER OF CTN='{result['NUMBER OF CTN']}'")
                        except Exception:
                            pass
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                        try:
                            print(f"[主表解析] GROSS WEIGHT='{result['GROSS WEIGHT']}'")
                        except Exception:
                            pass
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value
                        try:
                            print(f"[主表解析] QUANTITY OF PARCELS='{result['QUANTITY OF PARCELS']}'")
                        except Exception:
                            pass

        # === 4. 提取渠道 CTN：按行首单元格匹配渠道，第二列为 CTN ===
        unmatched_cells = []
        try:
            tables = soup.find_all("table")
            for table in tables:
                rows = table.find_all("tr")
                for row in rows:
                    tds = row.find_all("td")
                    if len(tds) < 4:  # 至少4列
                        continue

                    channel_raw = tds[0].get_text(strip=True).strip()
                    ctn_str = tds[1].get_text(strip=True)
                    parcels_str = tds[2].get_text(strip=True)
                    weight_str = tds[3].get_text(strip=True)

                    # 跳过标题行
                    if any(k in channel_raw for k in ["MAWB", "CTN", "parcels", "Weight", "Channel", "Gross"]):
                        continue

                    # 匹配标准渠道
                    std = exact_match_to_std.get(channel_raw)
                    if not std:
                        unmatched_cells.append(channel_raw)
                        continue

                    # 提取数字
                    ctn = num_re.search(ctn_str.replace(',', '')).group(0) if num_re.search(
                        ctn_str.replace(',', '')) else "N/A"
                    parcels = num_re.search(parcels_str.replace(',', '')).group(0) if num_re.search(
                        parcels_str.replace(',', '')) else "N/A"
                    weight = num_re.search(weight_str.replace(',', '')).group(0) if num_re.search(
                        weight_str.replace(',', '')) else "N/A"

                    # 累加（取最大值）
                    def to_float(s):
                        try:
                            return float(s.replace(',', ''))
                        except:
                            return 0.0

                    for key, new_val in [
                        (f"{std}_CTN", ctn),
                        (f"{std}_PARCELS", parcels),
                        (f"{std}_WEIGHT", weight)
                    ]:
                        old_val = result.get(key, "N/A")
                        if old_val == "N/A":
                            result[key] = new_val
                        else:
                            result[key] = str(max(to_float(old_val), to_float(new_val)))

        except Exception as e:
            print(f"[渠道提取异常] {e}")

        result["未识别渠道"] = " | ".join(list(set(unmatched_cells))) if unmatched_cells else "N/A"
        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 0
    for email_id in email_id_list[:int(limit_param)]:

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 渠道汇总调试打印：按既定顺序输出各渠道的最终值
            try:
                summary = {ch: info.get(ch, 'N/A') for ch in channel_order}
                print(f"[渠道汇总] {summary}")
                print(f"[UNI最终值] {info.get('UNI', 'N/A')}")
            except Exception:
                pass

            # 展平数据：按你指定的头部顺序
            flat_info = {
                "MAWB": info.get("MAWB", "N/A"),
                "口岸": "",
                "月份": "",
                "ETA": info.get("ETA", "N/A"),
                "CTN": info.get("NUMBER OF CTN", "N/A"),
                "PARCELS": info.get("QUANTITY OF PARCELS", "N/A"),
                "weight": info.get("GROSS WEIGHT", "N/A"),
                "COE weight": info.get("COE/UP_WEIGHT", "N/A"),
                "DHL weight": info.get("DHLe_WEIGHT", "N/A"),
                "SPX weight": info.get("SPX_WEIGHT", "N/A"),
                "usps weight": info.get("USPS_WEIGHT", "N/A"),
            }

            # 追加渠道 CTN（按统一顺序）
            for ch in channel_order:
                flat_info[f"{ch}_CTN"] = info.get(f"{ch}_CTN", "N/A")
                flat_info[f"{ch}_PARCELS"] = info.get(f"{ch}_PARCELS", "N/A")
                flat_info[f"{ch}_WEIGHT"] = info.get(f"{ch}_WEIGHT", "N/A")

                # 关键！加进 results
            results.append(flat_info)
            processed_count += 1
            update_output_text(output_text, f"已处理 {processed_count} 个邮件\n")
        else:
            continue

    # ========= 表头（第1行）=========
    # 最终表头（按你给定的顺序与命名）
    header_fixed = [
        "MAWB", "口岸", "月份", "ETA", "CTN", "PARCELS", "weight",
        "COE weight", "DHL weight", "SPX weight", "usps weight"
    ]

    header_channels = []
    for ch in channel_order:
        header_channels.extend([f"{ch}_CTN"])

    header_keys = header_fixed + header_channels

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    df = pd.DataFrame(results, columns=header_keys)

    for col in df.columns:
        if col == "USPS_CTN":
            df[col] = df[col].apply(lambda x: "N/A" if x == "N/A" else -(-float(x) // 10))  # 除10向上取整
        elif col.endswith("_CTN"):
            df[col] = df[col].apply(lambda x: "N/A" if x == "N/A" else -(-float(x) // 20))  # 除20向上取整


    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")


def wipe_off_ord(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "getemailord.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件，即将继续\n")
            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n")
            return {}, None

        except Exception as e:
            update_output_text(output_text, f"读取 cookie 失败: {type(e).__name__}: {e}\n")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "100",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            update_output_text(output_text, "cookies.txt 读取失败！\n")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            data = response.json()
            # 打印完整 JSON（邮件内容）
            try:
                print("[JSON-邮件内容] 以下为接口返回的完整 JSON：")
                print(json.dumps(data, ensure_ascii=False, indent=2))
            except Exception as e:
                print(f"[JSON-邮件内容] 打印失败: {e}")
            return data  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # 统一渠道顺序与别名映射（定义一次，全局复用）
    channel_order = [
        "COE/UP","GOFO","TE", "UNI","DHL","IB","SPX", "ACI",  "FEDEX","USPS","YW EXP", "ATL-GOFO", "ATL-DHL","ATL-ACI","ATL-USPS"
    ]


    # 使用“规范化键”：全部小写、去空格与连字符，提升匹配鲁棒性
    exact_match_to_std = {
        "GOFO": "GOFO",
        "YW EXPRESS":"YW EXP",
        "TOOEXPRESS": "TE",
        "TOOEXPRESS-DF": "TE-DF",
        "UNIUNI": "UNI",
        "OC-UNI": "OC-UNI",
        "DHL": "DHL",
        "IB": "IB",
        "SPX": "SPX",
        "ACI": "ACI",
        "FEDEX GROUND": "FEDEX",
        "USPS-GA": "USPS",
        "COE": "COE/UP",
        "ATL-GOFO": "ATL-GOFO",
        "ATL-USPS": "ATL-USPS",
        "ATL-ACI": "ATL-ACI",
        "ATL-DHL": "ATL-DHL",
    }


    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        try:
            print("[extract_flight_info] 开始解析航班信息")
        except Exception:
            pass

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        # 使用统一的渠道顺序与别名映射（channel_order, alias_to_standard）

        result = {
            "MAWB": "N/A",
            "ETA": "N/A",
            "NUMBER OF CTN": "N/A",
            "GROSS WEIGHT": "N/A",
            "QUANTITY OF PARCELS": "N/A",
            "未识别渠道": "N/A",
        }

        # 初始化渠道默认值（不包含 COE/UP）
        for ch in channel_order:
            result[f"{ch}_CTN"] = "N/A"
            result[f"{ch}_PARCELS"] = "N/A"
            result[f"{ch}_WEIGHT"] = "N/A"
        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            try:
                print(f"[解析主表] 找到主表，行数={len(main_table.find_all('tr'))}")
            except Exception:
                pass
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                try:
                    print(f"[主表行] key='{key}' value_raw='{raw_value}'")
                except Exception:
                    pass

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                    try:
                        print(f"[主表解析] ETA='{result['ETA']}'")
                    except Exception:
                        pass
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                        try:
                            print(f"[主表解析] MAWB='{result['MAWB']}'")
                        except Exception:
                            pass
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                        try:
                            print(f"[主表解析] NUMBER OF CTN='{result['NUMBER OF CTN']}'")
                        except Exception:
                            pass
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                        try:
                            print(f"[主表解析] GROSS WEIGHT='{result['GROSS WEIGHT']}'")
                        except Exception:
                            pass
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value
                        try:
                            print(f"[主表解析] QUANTITY OF PARCELS='{result['QUANTITY OF PARCELS']}'")
                        except Exception:
                            pass

        # === 4. 提取渠道 CTN：按行首单元格匹配渠道，第二列为 CTN ===
        unmatched_cells = []
        try:
            tables = soup.find_all("table")
            for table in tables:
                rows = table.find_all("tr")
                for row in rows:
                    tds = row.find_all("td")
                    if len(tds) < 4:  # 至少4列
                        continue

                    channel_raw = tds[0].get_text(strip=True).strip()
                    ctn_str = tds[1].get_text(strip=True)
                    parcels_str = tds[2].get_text(strip=True)
                    weight_str = tds[3].get_text(strip=True)

                    # 跳过标题行
                    if any(k in channel_raw for k in ["MAWB", "CTN", "parcels", "Weight", "Channel", "Gross"]):
                        continue

                    # 匹配标准渠道
                    std = exact_match_to_std.get(channel_raw)
                    if not std:
                        unmatched_cells.append(channel_raw)
                        continue

                    # 提取数字
                    ctn = num_re.search(ctn_str.replace(',', '')).group(0) if num_re.search(
                        ctn_str.replace(',', '')) else "N/A"
                    parcels = num_re.search(parcels_str.replace(',', '')).group(0) if num_re.search(
                        parcels_str.replace(',', '')) else "N/A"
                    weight = num_re.search(weight_str.replace(',', '')).group(0) if num_re.search(
                        weight_str.replace(',', '')) else "N/A"

                    # 累加（取最大值）
                    def to_float(s):
                        try:
                            return float(s.replace(',', ''))
                        except:
                            return 0.0

                    for key, new_val in [
                        (f"{std}_CTN", ctn),
                        (f"{std}_PARCELS", parcels),
                        (f"{std}_WEIGHT", weight)
                    ]:
                        old_val = result.get(key, "N/A")
                        if old_val == "N/A":
                            result[key] = new_val
                        else:
                            result[key] = str(max(to_float(old_val), to_float(new_val)))

        except Exception as e:
            print(f"[渠道提取异常] {e}")

        result["未识别渠道"] = " | ".join(list(set(unmatched_cells))) if unmatched_cells else "N/A"
        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 0
    for email_id in email_id_list[:int(limit_param)]:

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 渠道汇总调试打印：按既定顺序输出各渠道的最终值
            try:
                summary = {ch: info.get(ch, 'N/A') for ch in channel_order}
                print(f"[渠道汇总] {summary}")
                print(f"[UNI最终值] {info.get('UNI', 'N/A')}")
            except Exception:
                pass

            # 展平数据：按你指定的头部顺序
            flat_info = {
                "MAWB": info.get("MAWB", "N/A"),
                "口岸": "ORD",
                "月份": "",
                "ETA": info.get("ETA", "N/A"),
                "weight": info.get("GROSS WEIGHT", "N/A"),
                "CTN": info.get("NUMBER OF CTN", "N/A"),
                "PARCELS": info.get("QUANTITY OF PARCELS", "N/A"),
                "COE weight": info.get("COE/UP_WEIGHT", "N/A"),
                "SPX weight": info.get("SPX_WEIGHT", "N/A"),
                "usps weight": info.get("USPS_WEIGHT", "N/A"),
                "DHL weight": info.get("DHLe_WEIGHT", "N/A"),
                "ACI weight": info.get("ACI_WEIGHT", "N/A"),

            }

            # 追加渠道 CTN（按统一顺序）
            for ch in channel_order:
                flat_info[f"{ch}_CTN"] = info.get(f"{ch}_CTN", "N/A")
                flat_info[f"{ch}_PARCELS"] = info.get(f"{ch}_PARCELS", "N/A")
                flat_info[f"{ch}_WEIGHT"] = info.get(f"{ch}_WEIGHT", "N/A")

                # 关键！加进 results
            results.append(flat_info)
            processed_count += 1
            update_output_text(output_text, f"已处理 {processed_count} 个邮件\n")
        else:
            continue

    # ========= 表头（第1行）=========
    # 最终表头（按你给定的顺序与命名）
    header_fixed = [
        "MAWB", "口岸", "月份", "ETA", "weight", "CTN", "PARCELS",
        "COE weight", "SPX weight", "usps weight", "DHL weight", "ACI weight"
    ]

    header_channels = []
    for ch in channel_order:
        header_channels.extend([f"{ch}_CTN"])

    header_keys = header_fixed + header_channels

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    df = pd.DataFrame(results, columns=header_keys)
    for col in df.columns:
        if col == "USPS_CTN":
            df[col] = df[col].apply(lambda x: "N/A" if x == "N/A" else -(-float(x) // 10))  # 除10向上取整
        elif col.endswith("_CTN"):
            df[col] = df[col].apply(lambda x: "N/A" if x == "N/A" else -(-float(x) // 20))  # 除20向上取整

    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")


def email_program_chicago(account, password, output_text, folder_id_param, limit_param):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "getemailord.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到用于输出的excel文件，即将继续\n")
            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            update_output_text(output_text, "未找到用于输出的excel文件，已生成，请再次运行代码\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到正确的桌面路径\n")
        sys.exit()  # 程序立即停止

    def read_cookies_from_txt():

        txt_file_path = os.path.join(desktop_path, "emailtoken.txt")

        # 3. 检查文件是否存在
        file_exists = os.path.exists(txt_file_path)

        if not file_exists:
            update_output_text(output_text, "未找到储存身份信息的文件，请重新运行邮件身份信息程序\n")
            return {}, None

        # 4. 尝试打开文件
        try:
            with open(txt_file_path, 'r', encoding='utf-8') as txt_file:

                # 5. 读取原始内容
                raw_content = txt_file.read()

                # 6. 重新定位文件指针 + 解析 JSON
                txt_file.seek(0)  # 必须重置指针！read() 后指针在末尾
                data = json.load(txt_file)

                # 7. 提取 cookies 和 xsrf_token
                cookies = data.get("cookies", {})
                xsrf_token = data.get("xsrf_token", None)

                return cookies, xsrf_token

        except json.JSONDecodeError as je:
            update_output_text(output_text, f"JSON 解析失败！错误: {je}\n")
            update_output_text(output_text, f"错误位置: line {je.lineno}, column {je.colno}\n")
            return {}, None

        except Exception as e:
            update_output_text(output_text, f"读取 cookie 失败: {type(e).__name__}: {e}\n")
            return {}, None

        # finally:
        #     print("成功读取cookie\n")

    def get_mail_list():
        # Step 1: 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            return None

        # Step 2: 正确的邮件列表接口（来自真实抓包）
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/queryMailList.txt"

        # Step 3: 正确的请求头（来自邮箱系统）
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": "https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all",
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Requested-With": "XMLHttpRequest",
            # 不要手动设置 Host，让 requests 自动处理
        }

        # Step 4: 正确的 payload（邮箱专用）
        payload = {
            "query": f'{{"folderIds":["{str(folder_id_param)}"]}}',  # 由第一个参数决定
            "showFrom": "1",
            "offset": "0",
            "length": "100",  # 每页数量
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # Step 5: 发送请求
        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            update_output_text(output_text, "正在获取邮件列表...\n")
            response = session.post(
                url=url,
                headers=headers,
                data=payload,
                timeout=15,
                verify=False  # 阿里内网自签证书
            )

            if response.status_code == 200:
                try:
                    result = response.json()

                    if "dataList" in result and result["dataList"]:
                        mails = result["dataList"]
                        update_output_text(output_text, f"成功获取 {len(mails)} 封邮件\n")
                        for mail in mails[:5]:
                            sender = mail.get("from", [{}])[0].get("name", "未知")
                            subject = mail.get("subject", "无主题")
                            date = mail.get("date", "")
                        return result
                    else:
                        update_output_text(output_text, "接口返回失败或无数据\n")
                        return result
                except:
                    update_output_text(output_text, "提取到后台数据\n")
                    return response.text
            else:
                update_output_text(output_text, "请求失败\n")
                return None

        except Exception as e:
            update_output_text(output_text, f"请求异常: {str(e)}\n")

            return None

    def extract_mail_ids(response_text):

        text = response_text.strip()

        # 情况1：JSONP 格式，去掉前缀和回调
        if text.startswith("/**/") or text.startswith("jQuery"):
            # 提取括号内的 JSON
            match = re.search(r'\((.*)\)', text, re.DOTALL)
            if match:
                text = match.group(1)
            else:
                update_output_text(output_text, "无法解析 JSONP 格式\n")
                return []

        try:
            data = json.loads(text)
            mail_ids = []
            for mail in data.get("dataList", []):
                mail_id = mail.get("mailId")
                if mail_id:
                    mail_ids.append(mail_id)
            return mail_ids
        except json.JSONDecodeError as e:
            update_output_text(output_text, f"JSON 解析失败: {e}\n")
            return []

    def get_mail_content(email_id):
        """
        输入：email_id 如 '101_0:DzzzzyKz5Ld$---.fAX-oZE'
        输出：dict，成功返回包含 body 的数据，失败返回 None
        """
        # 1. 读取 cookies 和 token
        cookies_dict, xsrf_token = read_cookies_from_txt()
        if not cookies_dict or not xsrf_token:
            update_output_text(output_text, "cookies.txt 读取失败！\n")
            return None

        # 2. 正确接口
        url = "https://mail.alibaba-inc.com/alimail/ajax/mail/loadMail.txt"

        # 3. 正确 payload（去掉 "mailId: " 前缀）
        payload = {
            "mailId": email_id,
            "full": "1",
            "_tpl_": "v5ForWebDing",
            "_refer_hash_": "",
            "_root_token_": "",
            "_csrf_token_": xsrf_token
        }

        # 4. 动态构造 Referer（关键！必须包含正确的 base64 编码的 email_id）
        # 构造 {id: "xxx", type: "mail", isDraftMail: false}
        ref_payload = {
            "id": email_id,
            "type": "mail",
            "isDraftMail": False
        }
        ref_b64 = base64.b64encode(json.dumps(ref_payload).encode('utf-8')).decode('utf-8')
        referer = f"https://mail.alibaba-inc.com/alimail/entries/v5.1/mail/folder-101/all/{ref_b64}"

        # 5. headers
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "zh-CN,zh;q=0.9",
            "Connection": "keep-alive",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://mail.alibaba-inc.com",
            "Referer": referer,  # 动态生成
            "Sec-Ch-Ua": '"Chromium";v="124", "Google Chrome";v="124", "Not-A.Brand";v="99"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"Windows"',
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
            "X-Alimail-Trace-Id": str(uuid.uuid4())
        }

        session = requests.Session()
        session.cookies.update(cookies_dict)

        try:
            response = session.post(
                url=url,
                data=payload,
                headers=headers,
                timeout=15,
                verify=False
            )
            response.raise_for_status()
            data = response.json()
            # 打印完整 JSON（邮件内容）
            try:
                print("[JSON-邮件内容] 以下为接口返回的完整 JSON：")
                print(json.dumps(data, ensure_ascii=False, indent=2))
            except Exception as e:
                print(f"[JSON-邮件内容] 打印失败: {e}")
            return data  # 返回 dict
        except Exception as e:
            update_output_text(output_text, f"请求失败: {e}\n")
            return None

    # 统一渠道顺序与别名映射（定义一次，全局复用）
    channel_order = [
        "GOFO", "FEDEX","TE", "UNI", "OC-UNI","ACI", "DHL", "IB", "SPX",   "YW EXP","USPS",
        "ATL-GOFO", "ATL-DHL","ATL-ACI","ATL-USPS"
    ]
    # 使用“规范化键”：全部小写、去空格与连字符，提升匹配鲁棒性
    exact_match_to_std = {
        "GOFO": "GOFO",
        "YW EXPRESS":"YW EXP",
        "TOOEXPRESS": "TE",
        "TOOEXPRESS-DF": "TE-DF",
        "UNIUNI": "UNI",
        "OC-UNI": "OC-UNI",
        "DHL": "DHL",
        "IB": "IB",
        "SPX": "SPX",
        "ACI": "ACI",
        "FEDEX GROUND": "FEDEX",
        "USPS-GA": "USPS",
        "COE": "COE/UP",
    }
    contains_match_to_std = {
        "ATL-GOFO": "ATL-GOFO",
        "ATL-USPS": "ATL-USPS",
        "ATL-ACI": "ATL-ACI",
        "ATL-DHL": "ATL-DHL",
    }

    # **************************************************************************************************************************
    def extract_flight_info(response_dict):
        """
        从 loadMail.txt 的 response 中提取航班信息
        返回字典，缺失字段用 "N/A"
        """
        try:
            html_body = response_dict["data"]["body"]
        except (KeyError, TypeError):
            print("response 结构错误，缺少 data.body")
            return {}

        soup = BeautifulSoup(html_body, "html.parser")

        try:
            print("[extract_flight_info] 开始解析航班信息")
        except Exception:
            pass

        # 正则：提取数字（支持 123, 1.23, 1,234.56）
        num_re = re.compile(r'[\d,]+\.?\d*')
        # 正则：匹配到分钟为止的时间（不包含时区）
        eta_re = re.compile(r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})')

        # 使用统一的渠道顺序与别名映射（channel_order, alias_to_standard）

        result = {
            "MAWB": "N/A",
            "FLIGHT NUMBER": "N/A",
            "ETA": "N/A",
            "NUMBER OF CTN": "N/A",
            "GROSS WEIGHT": "N/A",
            "QUANTITY OF PARCELS": "N/A",
            "BUP": "N/A",
            "美国统包标准配送资源": {
                "number of ctn": "N/A",
                "quantity of parcels": "N/A"
            },
            # 预留 COE 组合输出
            "COE (Parcels/CTNS)": "N/A",
        }

        # 初始化渠道默认值（不包含 COE/UP）
        for ch in channel_order:
            result[ch] = "N/A"
        # === 1. 提取主表信息 ===
        main_table = soup.find("table", align="center")
        if main_table:
            try:
                print(f"[解析主表] 找到主表，行数={len(main_table.find_all('tr'))}")
            except Exception:
                pass
            rows = main_table.find_all("tr")
            for row in rows:
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                try:
                    print(f"[主表行] key='{key}' value_raw='{raw_value}'")
                except Exception:
                    pass

                # 统一处理 value
                if "ETA" in key:
                    m = eta_re.search(raw_value)
                    result["ETA"] = m.group(1) if m else "N/A"
                    try:
                        print(f"[主表解析] ETA='{result['ETA']}'")
                    except Exception:
                        pass
                else:
                    # 提取纯数字
                    num_match = num_re.search(raw_value.replace(',', ''))  # 先去逗号再匹配
                    value = num_match.group(0) if num_match else "N/A"

                    if "MAWB No." in key:
                        result["MAWB"] = raw_value  # MAWB 保留完整
                        try:
                            print(f"[主表解析] MAWB='{result['MAWB']}'")
                        except Exception:
                            pass
                    elif "Flight Number" in key:
                        result["FLIGHT NUMBER"] = raw_value
                        try:
                            print(f"[主表解析] FLIGHT NUMBER='{result['FLIGHT NUMBER']}'")
                        except Exception:
                            pass
                    elif "Number of CTN" in key:
                        result["NUMBER OF CTN"] = value
                        try:
                            print(f"[主表解析] NUMBER OF CTN='{result['NUMBER OF CTN']}'")
                        except Exception:
                            pass
                    elif "Gross Weight" in key:
                        result["GROSS WEIGHT"] = value
                        try:
                            print(f"[主表解析] GROSS WEIGHT='{result['GROSS WEIGHT']}'")
                        except Exception:
                            pass
                    elif "Quantity of parcels" in key:
                        result["QUANTITY OF PARCELS"] = value
                        try:
                            print(f"[主表解析] QUANTITY OF PARCELS='{result['QUANTITY OF PARCELS']}'")
                        except Exception:
                            pass

        # === 2. 提取 distributor 模块：美国统包标准配送资源 ===
        distributor_tables = soup.find_all("table", align="center")
        target_distributor = None

        for table in distributor_tables:
            header = table.find("td", class_="distributorName")
            if header and "美国统包标准配送资源" in header.get_text(strip=True):
                target_distributor = table
                break

        if target_distributor:
            try:
                print("[解析统包] 开始解析 '美国统包标准配送资源' 模块")
            except Exception:
                pass
            rows = target_distributor.find_all("tr")
            for row in rows[1:]:  # 跳过标题行
                tds = row.find_all("td")
                if len(tds) != 2:
                    continue
                key = tds[0].get_text(strip=True)
                raw_value = tds[1].get_text(strip=True)

                num_match = num_re.search(raw_value.replace(',', ''))
                value = num_match.group(0) if num_match else "N/A"

                if "Number of CTN" in key:
                    result["美国统包标准配送资源"]["number of ctn"] = value
                    try:
                        print(f"[解析统包] number of ctn='{value}'")
                    except Exception:
                        pass
                elif "Quantity of parcels" in key:
                    result["美国统包标准配送资源"]["quantity of parcels"] = value
                    try:
                        print(f"[解析统包] quantity of parcels='{value}'")
                    except Exception:
                        pass

        # === 3. 提取 "The MAWB is BUP" 中的 BUP 值 ===
        try:
            all_text = " ".join(soup.stripped_strings)
            m = re.search(r"The\s+MAWB\s+is\s*([A-Za-z0-9\-_/]+)", all_text, flags=re.IGNORECASE)
            if m:
                result["BUP"] = m.group(1)
                try:
                    print(f"[BUP识别] 值='{result['BUP']}'")
                except Exception:
                    pass
            else:
                # 退化方案：在包含该短语的标签中查找后续文本
                node = soup.find(string=re.compile(r"The\s+MAWB\s+is", re.IGNORECASE))
                if node:
                    next_text = node.parent.get_text(strip=True)
                    m2 = re.search(r"The\s+MAWB\s+is\s*([A-Za-z0-9\-_/]+)", next_text, flags=re.IGNORECASE)
                    if m2:
                        result["BUP"] = m2.group(1)
                        try:
                            print(f"[BUP识别-退化] 值='{result['BUP']}'")
                        except Exception:
                            pass
        except Exception:
            pass

        # === 4. 提取渠道 CTN：按行首单元格匹配渠道，第二列为 CTN ===
        unmatched_cells = []  # 用来收集未匹配的 <td> 内容
        try:
            tables = soup.find_all("table")
            try:
                print(f"[渠道扫描] 共{len(tables)}个表")
            except Exception:
                pass

            for ti, table in enumerate(tables, start=1):
                rows = table.find_all("tr")
                for ri, row in enumerate(rows, start=1):
                    tds = row.find_all("td")
                    if len(tds) < 2:
                        continue

                    raw_first = tds[0].get_text(strip=True).strip()
                    if not raw_first:
                        continue

                    # 过滤主表标题行
                    if any(keyword in raw_first for keyword in [
                        "MAWB", "Flight", "origin", "destination", "ETD", "ETA",
                        "Number of CTN", "Gross Weight", "Quantity", "parcels"
                    ]):
                        print(f"[跳过主表标题] 原文='{raw_first}'")
                        continue

                    # ---------- 1. 完全匹配 ----------
                    std = exact_match_to_std.get(raw_first)  # 完全相等
                    match_type = "exact" if std else None

                    # ---------- 2. 包含匹配 ----------
                    if not std:
                        for keyword, target in contains_match_to_std.items():
                            if keyword in raw_first:
                                std = target
                                match_type = "contains"
                                break

                    # ---------- 3. 没匹配到 → 记录 ----------
                    if not std:
                        unmatched_cells.append(raw_first)
                        try:
                            print(f"[渠道未识别] 表{ti}行{ri} 原文='{raw_first}'")
                        except Exception:
                            pass
                        continue

                    # ---------- 4. 标题/说明行过滤（可选） ----------
                    if re.search(r"(媒体|渠道)", raw_first):
                        try:
                            print(f"[可能标题/说明] 表{ti}行{ri} 原文='{raw_first}' → 匹配为'{std}'")
                        except Exception:
                            pass

                    # ---------- 5. COE/UP 组合 ----------
                    if std == "COE/UP":
                        # （保持原来的 COE 逻辑不变）
                        ctn_cell = tds[1].get_text(strip=True)
                        parcels_cell = tds[2].get_text(strip=True) if len(tds) >= 3 else ""
                        ctn_num = (num_re.search(ctn_cell.replace(',', '')) or re.search(r"\d+", ctn_cell))
                        parcels_num = (num_re.search(parcels_cell.replace(',', '')) or re.search(r"\d+", parcels_cell))
                        ctn_val = ctn_num.group(0) if ctn_num else "N/A"
                        parcels_val = parcels_num.group(0) if parcels_num else "N/A"
                        if parcels_val != "N/A" and ctn_val != "N/A":
                            result["COE (Parcels/CTNS)"] = f"{parcels_val}/{ctn_val}"
                        else:
                            result["COE (Parcels/CTNS)"] = ctn_val if ctn_val != "N/A" else "N/A"
                        try:
                            print(
                                f"[渠道识别-COE] 表{ti}行{ri} 原文='{raw_first}' CTN='{ctn_val}' PARCELS='{parcels_val}'")
                        except Exception:
                            pass
                        continue

                    # ---------- 6. 普通渠道 CTN ----------
                    ctn_cell = tds[1].get_text(strip=True)
                    num_match = num_re.search(ctn_cell.replace(',', ''))
                    new_value_str = num_match.group(0) if num_match else (ctn_cell if ctn_cell else "N/A")

                    def to_int(s):
                        try:
                            s_clean = str(s).replace(',', '').strip()
                            if s_clean.isdigit():
                                return int(s_clean)
                            m = re.search(r"\d+", s_clean)
                            return int(m.group(0)) if m else None
                        except Exception:
                            return None

                    old_value_str = result.get(std, "N/A")
                    old_n = to_int(old_value_str)
                    new_n = to_int(new_value_str)

                    # === 合并 TE 和 TE-DF ===
                    if std == "TE-DF":
                        # 转为 TE 并累加
                        std = "TE"  # 强制映射为 TE
                        old_value_str = result.get("TE", "N/A")
                        old_n = to_int(old_value_str)

                    # === 正常合并逻辑 ===
                    chosen_str = old_value_str
                    if old_n is None and new_n is not None:
                        chosen_str = str(new_n)
                    elif old_n is not None and new_n is None:
                        chosen_str = str(old_n)
                    elif old_n is not None and new_n is not None:
                        chosen_str = str(old_n + new_n)  # 关键：相加！
                    else:
                        if str(old_value_str).upper() == "N/A" and str(new_value_str).strip():
                            chosen_str = new_value_str

                    # 最终写入合并后的 TE（TE-DF 已消失）
                    result[std] = chosen_str

                    try:
                        print(
                            f"[渠道识别] 表{ti}行{ri} 标准='{std}' 原文='{raw_first}' 匹配方式='{match_type}' "
                            f"第二列='{ctn_cell}' 旧='{old_value_str}' 新='{new_value_str}' => 取='{chosen_str}'"
                        )
                    except Exception:
                        pass

        except Exception as e:
            print(f"[渠道提取异常] {e}")

        # 把未匹配的单元格内容放进结果（后面写 Excel 时取）
        result["未识别渠道"] = " | ".join(unmatched_cells) if unmatched_cells else "N/A"
        return result

    raw_query = get_mail_list()
    email_id_list = extract_mail_ids(raw_query)
    results = []
    processed_count = 0
    for email_id in email_id_list[:int(limit_param)]:

        result = get_mail_content(email_id)

        if result and result.get("status") in [0, 6]:
            info = extract_flight_info(result)  # 调用你定义的函数

            # 渠道汇总调试打印：按既定顺序输出各渠道的最终值
            try:
                summary = {ch: info.get(ch, 'N/A') for ch in channel_order}
                print(f"[渠道汇总] {summary}")
                print(f"[UNI最终值] {info.get('UNI', 'N/A')}")
            except Exception:
                pass

            # 展平数据：按你指定的头部顺序
            flat_info = {
                "未识别渠道": info.get("未识别渠道", "N/A"),
                "MAWB #": info.get("MAWB", "N/A"),
                "FLIGHT #": info.get("FLIGHT NUMBER", "N/A"),
                "PMC": info.get("BUP", "N/A"),
                "ETA": info.get("ETA", "N/A"),
                "PICKUP": "",
                "WEIGHT (KG)": info.get("GROSS WEIGHT", "N/A"),
                "CTNS": info.get("NUMBER OF CTN", "N/A"),
                "PARCELS": info.get("QUANTITY OF PARCELS", "N/A"),
                "PMC #": "",
                "INBOUND 2020": "",
                "CUSTOMS RELEASE": "",
                "HOLD": "",
                "COE (Parcels/CTNS)": info.get("COE (Parcels/CTNS)", "N/A"),

            }

            # 追加渠道 CTN（按统一顺序）
            for ch in channel_order:
                flat_info[ch] = info.get(ch, "N/A")
            flat_info["未识别渠道"] = info.get("未识别渠道", "N/A")
            results.append(flat_info)
            processed_count += 1
            update_output_text(output_text, f"已处理 {processed_count} 个邮件\n")
        else:
            continue

    # ========= 表头（第1行）=========
    # 最终表头（按你给定的顺序与命名）
    header_fixed = ["未识别渠道",
                    "MAWB #", "FLIGHT #", "PMC", "ETA", "PICKUP", "WEIGHT (KG)", "CTNS", "PARCELS", "PMC #",
                    "INBOUND 2020", "CUSTOMS RELEASE", "HOLD",
                    "COE (Parcels/CTNS)",
                    # 新增：放在 COE 之后，渠道之前
                    ]
    header_keys = header_fixed + channel_order

    # ========= 写入 Excel（使用你定义的 file_path，从第2行开始）=========
    df = pd.DataFrame(results, columns=header_keys)

    update_output_text(output_text, "正在写入 Excel...\n")
    try:
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='预报数据', index=False, startrow=0, header=True)
            writer.close()
        update_output_text(output_text, f"写入完成，文件：{file_path}\n")
    except Exception as e:
        update_output_text(output_text, f"写入 Excel 失败: {e}\n")
        return
    update_output_text(output_text, f"所有邮件处理完成，共 {processed_count} 封。返回代码结束。\n")

def tax_compare_broker(output_text):
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "taxcheck.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "taxcheck\n")
            pass
        else:
            # 创建空的文本文件
            with open(file_path, 'w', encoding='utf-8'):
                pass
            sys.exit()  # 程序立即停止
    else:
        sys.exit()  # 程序立

    if desktop_path:
        folder_path = os.path.join(desktop_path, "taxcheck")
        if os.path.exists(folder_path):
            update_output_text(output_text, "taxcheck\n")
            pass
        else:
            # Create an empty folder
            os.makedirs(folder_path, exist_ok=True)
            sys.exit()  # Program stops immediately
    else:
        sys.exit()  # Program stops immediately
    # 即停止

    try:
        df = pd.read_excel(file_path, header=None)  # 无标题行
    except Exception as e:
        update_output_text(output_text, f"读取 Excel 文件失败: {e}\n")
        sys.exit()

    # 确保 A 列有数据
    if df.empty or df[0].isna().all():
        update_output_text(output_text, "A 列无数据！\n")
        sys.exit()

    try:
        update_output_text(output_text, "Step 7: 尝试读取 taxcheck.xlsx\n")
        df = pd.read_excel(file_path, header=None)  # 无标题行
        update_output_text(output_text, "Step 8: 成功读取 taxcheck.xlsx\n")
    except Exception as e:
        update_output_text(output_text, f"Step 7: 读取 Excel 文件失败: {e}，程序退出\n")
        sys.exit()

    # 检查 A 列是否有数据
    if df.empty or df[0].isna().all():
        update_output_text(output_text, "Step 9: A 列无数据！程序退出\n")
        sys.exit()
    else:
        update_output_text(output_text, f"Step 9: A 列包含 {len(df)} 行数据\n")

    df[4] = "N/A"  # E 列
    df[5] = "N/A"  # F 列
    df[6] = "N/A"  # G 列
    update_output_text(output_text, "Step 10: 已初始化 E, F, G 列为 N/A\n")

    # 获取 taxcheck 文件夹中的所有 .xls 和 .csv 文件
    xls_files = glob.glob(os.path.join(folder_path, "*.xls")) + glob.glob(os.path.join(folder_path, "*.csv"))
    update_output_text(output_text, f"Step 11: 找到 {len(xls_files)} 个 .xls/.csv 文件: {xls_files}\n")

    # 迭代 A 列的每个单号
    for index, order in df[0].items():
        update_output_text(output_text, f"\nStep 12: 处理行 {index + 1}，单号: {order}\n")
        if pd.isna(order):
            update_output_text(output_text, f"Step 13: 行 {index + 1} 单号为空，跳过\n")
            continue  # 跳过空值
        try:
            # 提取单号中 - 后面的数字
            order_str = str(order).strip()  # 去除前后空格
            number = order_str.split("-")[1] if "-" in order_str else None
            if not number:
                update_output_text(output_text, f"Step 14: 行 {index + 1} 单号 {order} 格式无效，跳过\n")
                continue
            number = number.strip()  # 去除提取数字的空格
            update_output_text(output_text, f"Step 14: 提取单号中的数字: {number}\n")

            # 查找匹配的 .xls 或 .csv 文件
            matched_file = None
            update_output_text(output_text, f"Step 15: 搜索文件名包含 '{number}' 的文件\n")
            for xls_file in xls_files:
                file_basename = os.path.basename(xls_file)
                update_output_text(output_text, f"Step 15.1: 检查文件: {file_basename}\n")
                if number in file_basename:
                    matched_file = xls_file
                    update_output_text(output_text, f"Step 15.2: 找到匹配文件: {matched_file}\n")
                    break
            if not matched_file:
                update_output_text(output_text, f"Step 15.3: 未找到包含数字 {number} 的文件，写入 N/A\n")
                df.at[index, 4] = number
                continue

            # 读取匹配的 Excel/CSV 文件
            try:
                update_output_text(output_text, f"Step 16: 尝试读取匹配文件: {matched_file}\n")
                if matched_file.endswith(".csv"):
                    target_df = pd.read_csv(matched_file)
                else:
                    target_df = pd.read_excel(matched_file)
                update_output_text(output_text, f"Step 17: 成功读取文件，行数: {len(target_df)}\n")
                if target_df.empty:
                    update_output_text(output_text, f"Step 18: 文件为空，写入 N/A\n")
                    df.at[index, 4] = number
                    continue

                # 检查 Duty 和 User Fee 列是否存在
                if "Duty" not in target_df.columns or "User Fee" not in target_df.columns:
                    update_output_text(output_text, f"Step 18: 文件缺少 'Duty' 或 'User Fee' 列，写入 N/A\n")
                    df.at[index, 4] = number
                    continue

                # 计算 Duty 和 User Fee 列的和（从第二行开始）
                update_output_text(output_text, f"Step 18: 计算 'Duty' 列和 'User Fee' 列的和，从第二行开始\n")
                sum_duty = pd.to_numeric(target_df["Duty"], errors="coerce").sum()  # Duty 列，从第二行开始
                sum_user_fee = pd.to_numeric(target_df["User Fee"], errors="coerce").sum()  # User Fee 列，从第二行开始
                update_output_text(output_text, f"Step 19: Duty 列和: {sum_duty}, User Fee 列和: {sum_user_fee}\n")

                # 写入结果到 E, F, G 列
                df.at[index, 4] = number  # E 列：单号中 - 后的数字
                df.at[index, 5] = sum_duty if not pd.isna(sum_duty) else "N/A"  # F 列：Duty 列和
                df.at[index, 6] = sum_user_fee if not pd.isna(sum_user_fee) else "N/A"  # G 列：User Fee 列和
                update_output_text(output_text, f"Step 20: 写入结果到行 {index + 1} - E: {number}, F: {sum_duty}, G: {sum_user_fee}\n")
            except Exception as e:
                update_output_text(output_text, f"Step 16: 处理文件 {matched_file} 时出错: {e}，写入 N/A\n")
                df.at[index, 4] = number
                df.at[index, 5] = "N/A"
                df.at[index, 6] = "N/A"
        except Exception as e:
            update_output_text(output_text, f"Step 14: 处理单号 {order} 时出错: {e}，写入 N/A\n")
            df.at[index, 4] = "N/A"
            df.at[index, 5] = "N/A"
            df.at[index, 6] = "N/A"

    # 保存修改后的 Excel 文件
    try:
        update_output_text(output_text, "Step 21: 尝试保存修改后的 taxcheck.xlsx\n")
        df.to_excel(file_path, index=False, header=None)
        update_output_text(output_text, "Step 22: 处理完成，结果已保存到 taxcheck.xlsx\n")
    except Exception as e:
        update_output_text(output_text, f"Step 21: 保存 Excel 文件失败: {e}\n")


def FDA_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    def get_fda_entry_status(entry_number):
        url = f"https://www.access.fda.gov/itacs/ws/api/submission/{entry_number}/?feiNum=null&token=0cAFcWeA4bdocblwHFTljvFqa3R0J9MmTPnL4y3c-ZWc-dFVlUW6_ua7RrUeBfJZ0eWw5OZvzUiHzYbi8jxmuzPPYdP6qb2t7565VZOVd8ETPtIGW9oavQ8Sy9Mv-zTGtfgcSX3WSzOjamHdgWysPtHC55CBPM_aHvqmHRbDEofVrqyjU-tJ6sn5cNO7sTffZ-DVwTjJwGgUC3GCUyXr-ExK7NYuJK44maAlK5jRtgwCbb4g-YjzCLK2dQNgn31pf8j0MMwjCq3cmEIYBG8dvH2pGVipjf4cRvI3ID0NBpFGPKT-B4CHg3wU5Pcx7oju6WUeldAN30Qnn7I_Rt3MC4VvxKwt3sye_IynRWC5McJ0nlFySsnD-qWuIuFGXNl-FFid8Te6BunF_xtljwm1TKFSZ7aug-SLt44dzCL_ljLCoWVVXh0j64_JWNDknU1VqbfycWggHlPF1Txgh1_6Z7jZw-DKXBZj9Vy8A-zefvyfX5yBgWUubsAEEV1JPHKIyc7n5JWPzj5SoZ8_5tFLKJJnv4mEHLC2HQI_Qs6AFidS3JQdfuUlk1Nnh9Llrw0TFCMzndL4FJPI2y9mV0LnRiL7OQHrX1pa1wNFkHdMrmWoPLo89rHtftYKyuOp6IegWoha1CsivbD2SqyLGvPtxlXEdG2oOaH7OUEvWMNIp1S52Pzn5_9zYc2t9ddLmPskozKl78np2VEDmaAOFX5dvNYaXALBd8D2uIILPcg9d3Ux-p2D3k9CTNRLXRtO8IafAAJTefdCHxjyF5Kz1t-vPEE1u9jTOk1DkunSaVDsTgpvRvvDqebSOstg3Rn0tXd7-B1rpEJHwz09PU0-4vgPlwmAMTF6cFleF8mhG0D4nIaD2B9oa-9ryTUeo5jticNmeR3G9yBRNEXThh6bE1jZl2xRgmGgIZqHQXa2RC7j1r_cK4VoIv0r6Uq8Vg8JZI_boZsyncT3wyBzdkN17HUxglEVK8eR5zf1vUlU3iHmCiTHWsuyGaq6V2ie-N8admgEL5s3H6dqDdUYY961Ko4KkwZ3nhXMv9764I0QmxMk5Dkt-atvtwJr2Cqy6VRrims4S9ddVh1wdwRXOzf7FonHS6yiiM63sfMOSI7kyz0q3Xvn0bI9nIR1wTJydrsOdXkACwOaKCqCdZQCWUub23FPNXRAB2WUblWG_2bw-LdD5A2uxtHMnhPcFcVjGLeU4e8B2BBABuernaMTtTkYGJUzuZVhydvn8ITs538lPX-hKKWAdWaczpNPfuWc_jPM9zh5bAPQ82oqhWJd1ESMrCcyaZLojKjnGiDBaOGLiqAS6JfP8-nyHQaMySSXcnnaYicV7qxK65q282qZBa5s63-wC8bR6Q0unzZUWZXRwkO84Q0jxxcwizSD8quAZFLPSQbQFK8WPBW66eRk0rANpp8aGROxGWIBW4gg8PWSDFlX5mG8foUpV-eVUE9kXF8pbBl4SVxtacaMjvFV0hmhvnE5V4fbWlNQmvjC9_DhDAU5vKoTgOc0BPTXSbXKulLa23w8eL7SNcBFzSOy0cOfk5TqJxLajRV6dWBJuIY2LfWnhJTPOen3Vei-PUVKDygWvr8L6kmWKbIAqtE1HNMKSYgOEKtyfJdBNRNzZS-w"

        headers = {
            "accept": "application/json, text/plain, */*",
            "authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlcyI6IltcIlBVQkxJQ1wiXSIsImlzcyI6ImF1dGgwIiwiY3JlYXRlVGltZXN0YW1wIjoxNzU1ODk3NTQ3NTcxfQ.WCnz5k1mMk4pfBFa3zzCa_r4GoH9l3_1jMfxPTX5n6w",
            "referer": "https://www.access.fda.gov/itacs/",
            "user-agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 CrKey/1.54.250320"
        }

        session = requests.Session()
        retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
        session.mount('https://', HTTPAdapter(max_retries=retries))

        try:
            response = session.get(url, headers=headers, timeout=30)
            if response.status_code == 200:
                return response.json()
            else:
                print(f"Error: {response.status_code}")
                return "N/A"
        except (ConnectionError, Timeout, RequestException) as e:
            print(f"请求失败: {e}")
            return "N/A"

    def get_cpsc_entry_status(entry_number):
        url = "https://www.cpsc.gov/shipmenttracking/api/entries"

        headers = {
            "accept": "*/*",
            "content-type": "application/json",
            "origin": "https://www.cpsc.gov",
            "referer": "https://www.cpsc.gov/shipmenttracking/",
            "user-agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 CrKey/1.54.250320"
        }
        payload = {
            "entry_number": entry_number,
            "entry_line_number": "",
            "page_number": "",
            "page_size": ""
        }

        session = requests.Session()
        retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
        session.mount('https://', HTTPAdapter(max_retries=retries))

        try:
            response = session.post(url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()  # 如果不是 200，会抛异常
            return response.json()
        except (ConnectionError, Timeout, RequestException) as e:
            print(f"请求失败: {e}")
            return "N/A"

    data = get_cpsc_entry_status('NUP18426901')
    print(data)

    def check_status_for_keyword(data):
        """
        检查 entry_lines 中的每一行 public_status 是否都包含
        "Released by" 或 "Entry Data Received"
        返回两个参数:
            - status (str): "released" 或 "not released: {status}"
            - earliest_proceed_date (str): 最早的日期，格式 MM/DD/YYYY hh:mm:ss AM/PM TZ，若无有效日期返回 ""
        """
        # 处理 data 为 "N/A" 的情况
        if data == "N/A":
            return "not found", ""

        entry_lines = data.get("entry_lines", [])
        if not entry_lines:
            return "not found", ""

        # 收集所有合法的 proceed_date
        dates = []
        for line in entry_lines:
            spcs_proceed_date = line.get("proceed_date", "").strip()
            if spcs_proceed_date and spcs_proceed_date.lower() != "n/a":
                try:
                    pd_no_tz = " ".join(spcs_proceed_date.split()[:-1])  # 去掉最后的 EDT
                    spcs_proceed_date_proceeded = datetime.strptime(pd_no_tz, "%m/%d/%Y %I:%M:%S %p")
                    dates.append(spcs_proceed_date_proceeded)
                except ValueError:
                    # 日期格式不匹配，忽略
                    pass

        earliest_date = min(dates).strftime("%m/%d/%Y %I:%M:%S %p") if dates else ""

        # 检查每条 public_status
        for line in entry_lines:
            status_text = line.get("public_status", "").lower()
            if "released" not in status_text and "entry data received" not in status_text:
                return f"not released: {line.get('public_status', '')}", earliest_date

        return "released", earliest_date

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")

    # 打开 Excel
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active
    first_column_values = [ws.cell(row=row, column=1).value for row in range(1, ws.max_row + 1)]
    update_output_text(output_text, f"所有要处理的entry:{first_column_values}\n")
    # 遍历第一列，获取 entry_number 并调用接口
    GREEN = PatternFill(start_color="00C6EFCE", end_color="00C6EFCE", fill_type="solid")  # 绿色
    RED = PatternFill(start_color="00FFC7CE", end_color="00FFC7CE", fill_type="solid")  # 红色

    # 初始化结果列表
    fda_results = []
    cpsc_results = []

    # 遍历第一列
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active
    for row in range(1, ws.max_row + 1):
        cell_value = str(ws.cell(row=row, column=1).value)

        # 检查表头（避免对表头调用 API）
        if row == 1 and "entry" in cell_value.lower():
            fda_results.append("FDA Header")
            cpsc_results.append(("CPSC Header", ""))
            update_output_text(output_text, f"{cell_value}是表头，跳过API调用\n")
            continue

        # 检查 cell_value 是否为 8 位数字
        if not (cell_value.isdigit() and len(cell_value) == 8):
            fda_results.append("格式错误")
            cpsc_results.append(("格式错误", "格式错误"))
            update_output_text(output_text, f"{cell_value}格式错误，需为8位数字\n")
            continue

        # 格式化 entry number
        fda_entry_number = f"NLJ-{cell_value[:-1]}-{cell_value[-1]}" if len(cell_value) >= 2 else cell_value
        cpsc_entry_number = f"NLJ{cell_value}" if len(cell_value) >= 2 else cell_value

        # 获取 FDA 状态
        response1 = get_fda_entry_status(fda_entry_number)
        if not response1 or response1 == "N/A" or response1.get("status", "").upper() == "ERROR":
            entry_level_status1 = "FDA找不到此entry"
        else:
            if response1.get("entryLevelStatus") is None:
                if response1.get("entryActive", False):
                    entry_level_status1 = "No public status available"
                else:
                    entry_level_status1 = "entry closed"
            else:
                entry_level_status1 = response1.get("entryLevelStatus")

        # 获取 CPSC 状态
        response2 = get_cpsc_entry_status(cpsc_entry_number)
        if not response2 or response2 == "N/A":
            entry_level_status2 = "N/A"
            entry_level_status2_time = ""
        else:
            entry_level_status2, entry_level_status2_time = check_status_for_keyword(response2)

        fda_results.append(entry_level_status1)
        cpsc_results.append((entry_level_status2, entry_level_status2_time))
        update_output_text(output_text, f"{cell_value}运行完成\n")

    # 批量写入

    for row, (fda_res, cpsc_res) in enumerate(zip(fda_results, cpsc_results), start=1):
        # 写入第 3-5 列
        ws.cell(row=row, column=3, value=fda_res)
        ws.cell(row=row, column=4, value=cpsc_res[0])
        ws.cell(row=row, column=5, value=cpsc_res[1])

        # 第 3 列颜色标注
        if "FDA找不到此entry" in fda_res or "entry closed" in fda_res:
            ws.cell(row=row, column=3).fill = GREEN
        else:
            ws.cell(row=row, column=3).fill = RED

        # 第 6 列生成逻辑
        if "格式错误" in cpsc_res[0].lower():
            ws.cell(row=row, column=6, value="格式有问题跳过此行")
        else:
            if "not released" in cpsc_res[0].lower():
                ws.cell(row=row, column=6, value="CPSC REVIEW")
            elif "FDA找不到此entry" not in fda_res and "entry closed" not in fda_res:
                if "No public" in fda_res:

                    ws.cell(row=row, column=6, value="FDA REVIEW")
                elif "FDA entry status information is not" in fda_res:
                    ws.cell(row=row, column=6, value="MAY PROCEED")
                    ws.cell(row=row, column=7, value="Arrival Notifacation 也许可以放货")

                else:
                    ws.cell(row=row, column=6, value="FDA HOLD")

            else:
                ws.cell(row=row, column=6, value="MAY PROCEED")

    # 保存文件
    try:
        wb.save(file_path)
        update_output_text(output_text, "运行完成\n")
    except Exception as e:
        print(f"Error saving file: {e}")
        update_output_text(output_text, f"保存文件失败: {e}\n")

    wb.close()


ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# 用于停止线程的事件
stop_event = threading.Event()


def start_program(account, password, output_text, task_type, mode=None):
    stop_event.clear()  # 清除停止事件，准备开始任务

    if task_type == "itac检测":
        FDA_program(account, password, output_text)
    if task_type == "获取节点身份信息":
        node_token(account, password, output_text)
    if task_type == "获取email身份信息":
        email_token(account, password, output_text)
    if task_type == "EMAIL-MIA-4px":  # 新增
        email_program_mia_4px(account, password, output_text, 101, 20)
    if task_type == "EMAIL-MIA-AE":  # 新增
        email_program_mia_AE(account, password, output_text, 101, 20)
    if task_type == "email下载":
        # 保持原有调用，不改动此处
        email_program(account, password, output_text, 101, 20)  # 应该使用传入的参数
    if task_type == "email下载 ord":
        # 保持原有调用，不改动此处
        email_program_chicago(account, password, output_text, 101, 20)  # 应该使用传入的参数
    if task_type == "实报实销lax":
        # 保持原有调用，不改动此处
        wipe_off_lax(account, password, output_text, 101, 20)  # 应该使用传入的参数
    if task_type == "实报实销ord":
        # 保持原有调用，不改动此处
        wipe_off_ord(account, password, output_text, 101, 20)  # 应该使用传入的参数
    if task_type == "创建节点任务":
        # 保持原有调用，不改动此处
        creat_node_task(output_text)
    if task_type == "节点状态获取":
        # 保持原有调用，不改动此处
        node_status(output_text)
    if task_type == "节点上传":
        # 保持原有调用，不改动此处
        node_update(output_text)
    if task_type == "批次关税核对":
        tax_compare_broker(output_text)
    if task_type == "daily report":
        daily_report(output_text)
    # 登录界面


def login_window():
    global windowname
    windowname = 'login'

    login_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    login_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def proceed_login():
        account = entry_account.get()
        password = entry_password.get()
        if not account or not password:
            messagebox.showerror("错误", "账号或密码不能为空！")
            return
        login_frame.destroy()
        show_main_window(account, password)

    label_account = ctk.CTkLabel(login_frame, text="账号:", font=("Arial", 16), text_color="#FFFFFF")
    label_account.pack(pady=10)
    entry_account = ctk.CTkEntry(login_frame, width=300, height=35, font=("Arial", 12), placeholder_text="请输入账号")
    entry_account.pack(pady=10)

    label_password = ctk.CTkLabel(login_frame, text="密码:", font=("Arial", 16), text_color="#FFFFFF")
    label_password.pack(pady=10)
    entry_password = ctk.CTkEntry(login_frame, width=300, height=35, show="*", font=("Arial", 12),
                                  placeholder_text="请输入密码")
    entry_password.pack(pady=10)

    login_button = ctk.CTkButton(login_frame, text="确认", command=proceed_login, width=200, height=40,
                                 corner_radius=10)
    login_button.pack(pady=20)


# 主界面
def show_main_window(account, password):
    global windowname
    main_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    main_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def switch_to_task(task_type):
        global windowname
        main_frame.destroy()
        show_task_window(account, password, task_type)
        windowname = 'task'

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )

    scrollable_frame = ctk.CTkScrollableFrame(main_frame, fg_color="transparent", width=540, height=260)
    scrollable_frame.pack(pady=20, padx=10, fill="both", expand=True)

    buttons = [
                  ("itac检测", lambda: switch_to_task("itac检测")),
                  ("获取节点身份信息", lambda: switch_to_task("获取节点身份信息")),
                  ("获取email身份信息", lambda: switch_to_task("获取email身份信息")),
                  ("EMAIL-MIA-4px", lambda: switch_to_task("EMAIL-MIA-4px")),  # 新增
                  ("EMAIL-MIA-AE", lambda: switch_to_task("EMAIL-MIA-AE")),  # 新增
                  ("email下载", lambda: switch_to_task("email下载")),
                  ("email下载 ord", lambda: switch_to_task("email下载 ord")),
                  ("梦想成真模拟器", lambda: switch_to_task("梦想成真模拟器")),
                  ("实报实销lax", lambda: switch_to_task("实报实销lax")),
                  ("实报实销ord", lambda: switch_to_task("实报实销ord")),
                  ("节点状态获取", lambda: switch_to_task("节点状态获取")),
                  ("节点上传", lambda: switch_to_task("节点上传")),
                  ("创建节点任务", lambda: switch_to_task("创建节点任务")),
                  ("批次关税核对", lambda: switch_to_task("批次关税核对")),
                  ("daily report", lambda: switch_to_task("daily report"))
              ] + [("未解锁功能", None)] * 6  # 调整未解锁功能的数量

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )

    for i in range(9):  # 行
        for j in range(3):  # 列
            idx = i * 3 + j
            if idx < len(buttons):
                btn_text, btn_cmd = buttons[idx]
                btn = btn = create_button(scrollable_frame, btn_text, btn_cmd)
                btn.grid(row=i, column=j, padx=10, pady=10)


# 任务界面
def show_task_window(account, password, task_type):
    task_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    task_frame.pack(padx=20, pady=20, fill="both", expand=True)

    output_text = ctk.CTkTextbox(
        task_frame, width=520, height=120, font=("Consolas", 11),
        fg_color="#1e1e1e", text_color="#FFFFFF", corner_radius=10,
        border_width=2, border_color="#007acc"
    )
    # 非 email下载 模式，日志框按原位置显示；email下载模式下稍后再排版，保证返回按钮可见
    if task_type != "email下载" and task_type != "email下载 ord" and task_type != "实报实销lax" and task_type != "实报实销ord" and task_type != "EMAIL-MIA-4px" and task_type != "EMAIL-MIA-AE":
        output_text.pack(pady=10)

    # 在 email下载 与 email下载 ord 模式下显示两个数字输入框
    folder_id_entry = None
    limit_entry = None
    if task_type in ["email下载", "email下载 ord", "实报实销lax", "实报实销ord", "EMAIL-MIA-4px", "EMAIL-MIA-AE"]:
        label_folder = ctk.CTkLabel(task_frame, text="文件夹ID", text_color="#FFFFFF")
        label_folder.pack(pady=(5, 0))
        folder_id_entry = ctk.CTkEntry(task_frame, width=200, height=35)
        folder_id_entry.insert(0, "101")
        folder_id_entry.pack(pady=5)

        label_limit = ctk.CTkLabel(task_frame, text="提取邮件数量", text_color="#FFFFFF")
        label_limit.pack(pady=(5, 0))
        limit_entry = ctk.CTkEntry(task_frame, width=200, height=35)
        limit_entry.insert(0, "20")
        limit_entry.pack(pady=5)

    if task_type == "梦想成真模拟器":
        output_text.destroy()
        title_frame = ctk.CTkFrame(task_frame, fg_color="transparent")
        title_frame.pack(pady=30)

        dream_label1 = ctk.CTkLabel(title_frame, text="梦", text_color="#FF69B4",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label1.pack(side="left")
        dream_label2 = ctk.CTkLabel(title_frame, text="想", text_color="#00BFFF",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label2.pack(side="left")
        rest_label = ctk.CTkLabel(title_frame, text="成真模拟器", text_color="#FFFFFF",
                                  font=("Comic Sans MS", 26, "bold"))
        rest_label.pack(side="left")

        def transform_dreams():
            progress_win = Toplevel(root)
            progress_win.title("梦想成真中")
            progress_win.geometry("400x150")
            progress_win.configure(bg="white")

            label = tk.Label(progress_win, text="梦想成真中...", font=("Arial", 14), bg="white")
            label.pack(pady=10)

            progress_bar = ttk.Progressbar(progress_win, length=300, mode='determinate')
            progress_bar.pack(pady=10)
            progress_bar["value"] = 0

            def update_bar():
                for i in range(101):
                    progress_bar["value"] = i
                    label.config(text=f"梦想成真中... {i}%")
                    time.sleep(0.05)
                    progress_win.update_idletasks()

                label.config(text="🎉 梦想已成真 🎉")

                # ✅ 达到 100% 时立即替换文字
                def replace_text(widget):
                    try:
                        if hasattr(widget, "cget") and callable(widget.cget):
                            if "text" in widget.keys():
                                text = widget.cget("text")
                                if text:
                                    new_text = text.replace("梦想", "真的").replace("梦", "真").replace("想", "的")
                                    widget.configure(text=new_text)
                    except:
                        pass
                    for child in widget.winfo_children():
                        replace_text(child)

                replace_text(task_frame)

                # ✅ 自动 1 秒后关闭进度窗口
                time.sleep(1)
                progress_win.destroy()

            threading.Thread(target=update_bar, daemon=True).start()

        dream_button = ctk.CTkButton(
            task_frame,
            text="点击把梦想变成真的",
            command=transform_dreams,
            width=250,
            height=60,
            corner_radius=15,
            font=("Comic Sans MS", 18, "bold"),
            fg_color="#FF69B4",
            hover_color="#FF1493"
        )
        dream_button.pack(pady=40)

        back_button = ctk.CTkButton(task_frame, text="返回",
                                    command=lambda: go_back_to_main(task_frame, account, password),
                                    width=200, height=40, corner_radius=10)
        back_button.pack(pady=20)

        return  # 不继续执行下面的通用逻辑

    def start_task():
        output_text.insert("end", f"启动 {task_type} 任务...\n")
        # 统一需要输入参数的任务列表
        task_with_params = ["email下载", "email下载 ord", "实报实销lax", "实报实销ord", "EMAIL-MIA-4px", "EMAIL-MIA-AE"]

        if task_type in task_with_params:
            try:
                folder_id_val = int(folder_id_entry.get()) if folder_id_entry else 101
                limit_val = int(limit_entry.get()) if limit_entry else 20
            except Exception:
                messagebox.showerror("错误", "请输入有效的数字。")
                return

            # 使用字典映射来简化目标函数选择
            task_mapping = {
                "email下载": email_program,
                "email下载 ord": email_program_chicago,
                "实报实销lax": wipe_off_lax,
                "实报实销ord": wipe_off_ord,
                "EMAIL-MIA-4px": email_program_mia_4px,  # 新增
                "EMAIL-MIA-AE": email_program_mia_AE,  # 新增
            }

            target_func = task_mapping.get(task_type)

            threading.Thread(
                target=target_func,
                args=(account, password, output_text, folder_id_val, limit_val),
                daemon=True
            ).start()
        else:
            threading.Thread(
                target=start_program,
                args=(account, password, output_text, task_type),
                daemon=True
            ).start()

    if task_type == "email下载" or task_type == "email下载 ord" or task_type == "实报实销lax" or task_type == "实报实销ord" or task_type =="EMAIL-MIA-4px"or task_type == "EMAIL-MIA-AE":
        # 将“开始任务”和“返回”并排放到输入框下方，整洁且始终可见
        btn_row = ctk.CTkFrame(task_frame, fg_color="transparent")
        btn_row.pack(pady=6)

        start_button = ctk.CTkButton(btn_row, text="开始任务", command=start_task, width=120, height=36,
                                     corner_radius=10)
        start_button.pack(side="left", padx=6)

        back_button = ctk.CTkButton(
            btn_row, text="返回",
            command=lambda: go_back_to_main(task_frame, account, password),
            width=120, height=36, corner_radius=10
        )
        back_button.pack(side="left", padx=6)

        # email下载模式下，此时再显示日志框，位于按钮下方
        output_text.pack(pady=10)
    else:
        start_button = ctk.CTkButton(task_frame, text="开始任务", command=start_task)
        start_button.pack(pady=10)

        back_button = ctk.CTkButton(
            task_frame, text="返回",
            command=lambda: go_back_to_main(task_frame, account, password),
            width=200, height=40, corner_radius=10
        )
        back_button.pack(pady=20)


# 返回主界面并停止任务
def go_back_to_main(current_frame, account, password):
    global windowname
    print("销毁当前窗口...")  # 调试打印
    current_frame.destroy()
    stop_event.set()  # 设置停止事件，通知子线程退出
    show_main_window(account, password)
    windowname = 'main'


# 初始化主窗口
root = ctk.CTk()
root.title("代码测试中")
root.geometry("600x420")
root.configure(fg_color="#1e1e1e")

# 显示登录窗口
login_window()

# 启动 GUI 主循环
root.mainloop()
